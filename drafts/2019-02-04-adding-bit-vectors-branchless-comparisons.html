<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Haskell Works Blog - Adding bit vectors - Branchless Comparisons</title>
    <link rel="stylesheet" href="../css/default.css" />
    <link rel="alternate" type="application/atom+xml" title="Atom - Haskell Works Blog" href="../atom.xml" />
    <link rel="alternate" type="application/rss+xml" title="RSS - Haskell Works Blog" href="../rss.xml" />
  </head>
  <body>
    <header>
      <div class="logo">
        <a href="../">Haskell Works Blog</a>
      </div>
      <nav>
        <a href="../">Home</a>
        <a href="../about.html">About</a>
        <a href="../contact.html">Contact</a>
        <a href="../archive.html">Archive</a>
        <a href="../drafts.html">Drafts</a>
      </nav>
    </header>

    <main role="main">
      <h1>Adding bit vectors - Branchless Comparisons</h1>
      <article>
  <section class="header">
    Posted on February  4, 2019
    
      by John Ky
    
  </section>
  <section>
    <p>In a <a href="../posts/2018-08-15-data-parallel-rfc-compliant-csv-parsing.html">previous post</a>, I described how addition can be used flip runs of bits, but I left the method of adding large bit-vectors unexplained.</p>
<p>This post will fill this gap by explaining how to add large bit-vectors and how to do so efficiently.</p>
<p>Examples in this post will work with examples that use vectors of <code>Word8</code> in order to be concise in the explanation, whereas the real implementation will use vectors of <code>Word64</code> for efficiency.</p>
<p>As per usual, words when expressed in binary form are expressed in Little Endian.</p>
<h1 id="overflows">Overflows</h1>
<p>CPUs perform addition on registers of finite size. We shall describe the register in question as having <img width="12" alt="n" height="8" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAQCAQAAABJ7xwgAAAAwElEQVR4nH1SUQGFIAy8ClSgghWsQAUqWMEKVrACFaxABSrwjgciyPD48bbddgOBFht22MoM2c6YxhQHVqYDy4AFJ8UaitFAJmL5lwIOkVLH4gxF7mTJXnp5lvgqSIg8IlztmaY80HNJtmWYvrq4mRu7hbGI55EXrpetvNs6qca9SYuFPHzNGH0nW8eXZPSdbOXLt7K9tIl52fLl23VvVZA3aRPPVC3bG9/EVskpzcg9t8GqY6tz9mMqccGVp5vwAwSSR4bIEK69AAAAAElFTkSuQmCC" class="display-math" style="margin:0; vertical-align:-1px;" /> bits indexed from <img width="10" alt="0" height="11" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAXCAQAAABO1swWAAAAtUlEQVR4nLVTUQ3FIAw8C1h4FrCABSzMAhZmAQuzgAUszMIs8G68l7G1LCFZdvw012u5pgBITMhIPBkzjMoeMFVi/nHECnsnXbBdOrVCAYfCS8/wijl6FsqvhgpNdHwWHnndRk75dVUqkXoW5ltpHJemB9JlXJpe6frOWGF8Bf1treQmxdZ9O8Ht5R8tjaqDJZO1EKyWI+yj+p70l2oWLC2pp9IQmA418oy6P+BsI3BziTLxpL+zvWJJAJ3IsAAAAABJRU5ErkJggg==" class="display-math" style="margin:0; vertical-align:-1px;" /> to <img width="40" alt="n - 1" height="11" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAXCAQAAAA2RQDyAAABJ0lEQVR4nO2WgQ2EIAxFuwIrsAIrsAIruIIruIIruAIrsIIruILXgnp46NXkhOOS+yQmLWhe2voDQE0S0EP3bYgzKWhhhLlOwBmXQzRXK+Aq+wf8UL8P2OJ2s0UGow5zMjvYKgawB40wkz+iYEBU6Z1pwqgCQLVs0SGNT7HkBca2BB0wgN1SJzLLccMjkUuV0VvAUCXhcXSUl7UAhg3jPT2WqaXFQV1yJM3spfAnmi+s8R5A99LgMJP65HSQvrSuOAELKJJ5UxhPFz59j1jAdN6owX1WqFgsYDpv1ODQnIZp9B1iAWkCTRSraLjtzhvziAEMExhjPCsqizSaAUw9sNleGArUT/qBsueXE6pX+5Jz+IJBvLzXBXvgmweVFIe/AXlY/uqd6gGv0J4NH/vy5gAAAABJRU5ErkJggg==" class="display-math" style="margin:0; vertical-align:-1px;" />. When adding large integers, there inevitably comes a point where the resulting integer requires more than <img width="12" alt="n" height="8" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAQCAQAAABJ7xwgAAAAwElEQVR4nH1SUQGFIAy8ClSgghWsQAUqWMEKVrACFaxABSrwjgciyPD48bbddgOBFht22MoM2c6YxhQHVqYDy4AFJ8UaitFAJmL5lwIOkVLH4gxF7mTJXnp5lvgqSIg8IlztmaY80HNJtmWYvrq4mRu7hbGI55EXrpetvNs6qca9SYuFPHzNGH0nW8eXZPSdbOXLt7K9tIl52fLl23VvVZA3aRPPVC3bG9/EVskpzcg9t8GqY6tz9mMqccGVp5vwAwSSR4bIEK69AAAAAElFTkSuQmCC" class="display-math" style="margin:0; vertical-align:-1px;" /> bits to store and will not fit in the register and an overflow occurs.</p>
<p>During an overflow, the least <img width="12" alt="n" height="8" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAQCAQAAABJ7xwgAAAAwElEQVR4nH1SUQGFIAy8ClSgghWsQAUqWMEKVrACFaxABSrwjgciyPD48bbddgOBFht22MoM2c6YxhQHVqYDy4AFJ8UaitFAJmL5lwIOkVLH4gxF7mTJXnp5lvgqSIg8IlztmaY80HNJtmWYvrq4mRu7hbGI55EXrpetvNs6qca9SYuFPHzNGH0nW8eXZPSdbOXLt7K9tIl52fLl23VvVZA3aRPPVC3bG9/EVskpzcg9t8GqY6tz9mMqccGVp5vwAwSSR4bIEK69AAAAAElFTkSuQmCC" class="display-math" style="margin:0; vertical-align:-1px;" /> signifant bits of the result are stored in the target register resulting in a number that is smaller than at least one of the addends. The <img width="23" alt="n^{th}" height="15" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC4AAAAfCAQAAAAylje0AAABfUlEQVR4nK1Wbx2FIAykAhWoQAUqWIEKVqCCFaxABSpYwQq+DVAH8v4x7n14yg9u47gNheBDCgM/NYCpgVVs4hDzKDoLhBQOyPUo8k2E4t2LfRS1gjxdMXJUO2HAAtlE3s0YxTVk7ECEI/7bPJoUx3NY4Vn2kifT7aA4NR8qfoYKYuFk31L89grugoGW4ncwD05iYAEyqiv1uIRnliyfPI67svWC33ErjoeLoB5fc6DpufAX3Iq7SE49foqieqWZgQBJdSagipsceG13yJmUBm4OS2UupsroZHf5o3RHiIXUVH2JhbHHhTpOUkC2wEjZ8TQJp6qKNO0K1TkbHzfur0mopG8t+Acu54eNfyviH7yqQ6TsZKQyZFyNIE+iTEBUFsk0QpYzRN2WniPdCJUo6QzMm9l/QT701fA+6H586uu4fa6kKvXdrvK2XHFCdRHo6PkE3387IpLi9UWQdtLd6U48PW4v8pWXd8qz/v4IIMcE1OyPNdk8MvOu033HC4C7lp08z/D1AAAAAElFTkSuQmCC" class="display-math" style="margin:0; vertical-align:-1px;" /> bit, called the carry bit, would have been set to <img width="10" alt="1" height="11" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAWCAQAAABqSHSNAAAAPUlEQVR4nGNgwAYEGWYydGCVQQLGDOUMdxn+41f4HwjPAJWcIaQQBnaPKhxVOPQUKoGzwm4gjdckdAg1GQAqoT1dLNh+GwAAAABJRU5ErkJggg==" class="display-math" style="margin:0; vertical-align:-0px;" /> but due to lack of register storage is lost instead.</p>
<p>In order to perform additions on bit-vectors of greater than size <img width="12" alt="n" height="8" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAQCAQAAABJ7xwgAAAAwElEQVR4nH1SUQGFIAy8ClSgghWsQAUqWMEKVrACFaxABSrwjgciyPD48bbddgOBFht22MoM2c6YxhQHVqYDy4AFJ8UaitFAJmL5lwIOkVLH4gxF7mTJXnp5lvgqSIg8IlztmaY80HNJtmWYvrq4mRu7hbGI55EXrpetvNs6qca9SYuFPHzNGH0nW8eXZPSdbOXLt7K9tIl52fLl23VvVZA3aRPPVC3bG9/EVskpzcg9t8GqY6tz9mMqccGVp5vwAwSSR4bIEK69AAAAAElFTkSuQmCC" class="display-math" style="margin:0; vertical-align:-1px;" />, we will need to somehow perform repeated additions using register sized slices of the bit-vector, recover the carry bits and propagate them.</p>
<h1 id="recovering-the-carry">Recovering the carry</h1>
<p>As mentioned earlier, the carry bit is notionally set when there is an overflow and an overflow also results in a truncated value that is smaller than at least one of the addends.</p>
<p>We can therefore determine whether the carry bit should be set by testing for the latter condition: <img width="147" alt="total &lt; a \lor total &lt; b" height="12" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAScAAAAYCAQAAAASCPMGAAAEUUlEQVR4nN2bgbWrIAxAWYEVXIEVXMEVWKEruIIruIIruIIruEIfCfiKEgjQnveK8fxz/m+NCbchgeAX4j9FicVcq3iK8V/9aF3+kqMUM1p7mj9fJlL0BsDTXP1/u9K0/CVHsPUQe37oDib+ZLGZOi0hOsRwR7kzxy0/dCHyVLGBOi0h9DemTfPjLMyPCkm/S95xX44FoavMjXuxgTotkOlLV0474xUk/FTA3ZljQeg+zK1zsYE6LZCCtJmUoWpOx2VkwmVjw+2+HAtCdza3PoqdqNP6VMXXBuZuQHxSpPFLJyw+mVJ3Z44FobtV1e46rfcrvjSzZMPCVLN8TctknhyTxXyblvtyzAhd2P7BNbjtJlzXYXVm3ozm0r8mc7QgfYIWHc3vVPwOC9KWyCGUpLy5Pv8Zmal9dHbmEbmSbIvjEbrKjYF85IIXzI7N/d13T+Jc1eY+a1xlaYHJDXdAoK/RkTOm2orfIcClMJQ4b66yRGb8FM0EPBGKZFscbejC1aHnazyj0bUbBuMrTQZDx2rZOB69u66Drqv4vevJluLjvKEsUQHXJVdVx9NpImmSbXC0QX9w6VJ5kep6KEyFfgQC5onRsnf5s1gHgy6v+BoRTMwymBLeG0o2Yo00JtZUh9BEOJItcLSh6y8C1hhHuuuxBrNYnu6jtSRGse9uOOiyiq/dYrEcQZ43tM3nJZVL4wO394p1j9IkW+BIWV9iWZ7qeoyY2s7Sn+YH3SsBvfX0STjo3IovcZXxzv4txxtaru1Mrn1p74kRSZFsgSNlPXpWSNXunfhsOIUTXfFDvdqKr/BZZYvucm9iMl4yBte+BMklcibZAseYdZJkWLvtcK/1fDylZarih3rhoHMrvnQb2Uf1nMrxJm7d/wn49iVIHhEQn+T3c6SsWw8JJlTtHonP7BrgSMt0xQ/13qv48q2Kn+NNXPx2Jt++zCcC8iLZAkfKOlXCUajaPRHYz+mNrvhzxqDLeyUa8ZfvR3K8iYv69TPevvSFJsKRbIGjDZ7QOknyXLvniLr9bElq2dV+bND2Hj9tlhx62m7JXASQ94bTt+ONty99oYlwJFvgaD32V189Zk+yePrnRb0bxCMYjsS9gUpqhfBUMOhX2lTFxwPKzfXcQ1/em7QMuDrIaV+C0EQ4ki1wtKPwA3Aitw8o/iLreHkMEJ63qTCLBkbLRu1rcBKTqx304My/QI1Vh54ddpTzTpp4bziBdmZO+xKEJsKRbIHjtQd+bWef5NXdnLxh+vEo0XSfoSXwBOrQgkb+7jAsrmIr55i8QC6RY6/C91E4bzjRmNTzQi9GJE2yDY4C/+OBcJb31MZE4YpfB8lPoyFIwCthMKYFg5/xFNy+BKuxVMzeLLBHocubr7299iopFLw3nJU9o31pJUYkTbINjr4/K0fPvihBSR/9JqWlTi9adOZfXfD9Z95T0hmn4pw3nIX819riRFIkW+Fo7ZGe/gCP9ovSaqfi5AAAAABJRU5ErkJggg==" class="display-math" style="margin:0; vertical-align:-1px;" /></p>
<p>This allows us to write a function that returns both the sum and the carry:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="ot">sumCarryIncomplete ::</span> <span class="dt">Wor64</span> <span class="ot">-&gt;</span> <span class="dt">Wor64</span> <span class="ot">-&gt;</span> (<span class="dt">Wor64</span>, <span class="dt">Wor64</span>)</a>
<a class="sourceLine" id="cb1-2" title="2">sumCarryIncomplete a b <span class="fu">=</span> (total, carry)</a>
<a class="sourceLine" id="cb1-3" title="3">  <span class="kw">where</span> total     <span class="fu">=</span> a <span class="fu">+</span> b</a>
<a class="sourceLine" id="cb1-4" title="4">        carry  <span class="fu">=</span> <span class="kw">if</span> total <span class="fu">&lt;</span> a <span class="fu">||</span> total <span class="fu">&lt;</span> b <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span></a></code></pre></div>
<p>This is fine for adding the first two words in our bit-vector, but the addition of following pairs of words will need to incorporate the carry. This ends up being a threeway addition that includes the carry.</p>
<p>We should therefore extend the function to take <img width="42" alt="carry" height="11" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFUAAAAWCAQAAAAbMBgTAAACF0lEQVR4nM1XYaGEIAxeBSpQgQpWsIIVqGAFK1CBClawghV82xAYCJ737sfd/HHIN7YxPuYOoCUaLMz4TKAu2MjI0FhleUW0QFq2WP8K103LBuc7omCBDU1qHI3gUVUu28AxsqDGBIdAF3SiYUdngIhjxMP6GDf4plHnQK/S44HzTTFobE17pZBcwii0Ob05DPtIOTAn4nHO4kMy4/h4iCtEFP+WoZHO8jpQwHFeOFRGJuGITIb8bkKL3LiHuD2pMVZeaGsTXERxaJIre1JU7ESyZiqM+lPrKLTMYzwSYeGsZzkqr2KXazGjktoVWwo6hNF40XoPr7dCJ7m11PdqR/fYVp1AcCjDbwV0j0+CElG/wdSxl+yEyVqgC6ZGWav7+y7uKmZ2mDr3kn1iezFTMjVIOL5rJf4/3kme71cw3m2JLY2j7DPxf3iXqS3nUfwFy0zN3PqUqTXeram2aUixcm3ECKbmUD9lau2lw9RwUerjMeeHdSiMKPFpGFNd+JSpdbLMzTXnXcnyYzFj0bRPrKFP4ICXzJ/z0dinTA3J8mnsb645B7dxb2Px2H2RfArQcVflOLiJD8cJnfmmKj/Bga3u7J+8dJmaZeCndVAG53Nt1dwpyc20GsPnuPQfuq4OU39N9KWS/4zUrdKrwvZFCS1l7n77n6OvC/3fiDWXMrzelrUviz9zOnIV+uFAKZcWw/UYZqfs/wHcOSUdHiKxhAAAAABJRU5ErkJggg==" class="display-math" style="margin:0; vertical-align:-4px;" /> as an <code>Bool</code> argument so that it can also be added to the result (<a href="https://github.com/haskell-works/blog-examples/blob/dd02285e7ab791ec1d294cedd8affd774835ebbc/ex-vector/src/Ops/SumBitVectors/Branchiest.hs">full source</a>):</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="ot">sumCarry0 ::</span> <span class="dt">Word64</span> <span class="ot">-&gt;</span> <span class="dt">Word64</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> (<span class="dt">Word64</span>, <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb2-2" title="2">sumCarry0 a b carry <span class="fu">=</span> (total, newCarry)</a>
<a class="sourceLine" id="cb2-3" title="3">  <span class="kw">where</span> preTotal  <span class="fu">=</span> a <span class="fu">+</span> b</a>
<a class="sourceLine" id="cb2-4" title="4">        total     <span class="fu">=</span> <span class="kw">if</span> carry <span class="kw">then</span> preTotal <span class="fu">+</span> <span class="dv">1</span> <span class="kw">else</span> preTotal</a>
<a class="sourceLine" id="cb2-5" title="5">        newCarry  <span class="fu">=</span> total <span class="fu">&lt;</span> a <span class="fu">||</span> total <span class="fu">&lt;</span> b <span class="fu">||</span> (carry <span class="fu">&amp;&amp;</span> total <span class="fu">&lt;</span> <span class="dv">1</span>)</a></code></pre></div>
<p>This means that instead of relying on <img width="147" alt="total &lt; a \lor total &lt; b" height="12" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAScAAAAYCAQAAAASCPMGAAAEUUlEQVR4nN2bgbWrIAxAWYEVXIEVXMEVWKEruIIruIIruIIruEIfCfiKEgjQnveK8fxz/m+NCbchgeAX4j9FicVcq3iK8V/9aF3+kqMUM1p7mj9fJlL0BsDTXP1/u9K0/CVHsPUQe37oDib+ZLGZOi0hOsRwR7kzxy0/dCHyVLGBOi0h9DemTfPjLMyPCkm/S95xX44FoavMjXuxgTotkOlLV0474xUk/FTA3ZljQeg+zK1zsYE6LZCCtJmUoWpOx2VkwmVjw+2+HAtCdza3PoqdqNP6VMXXBuZuQHxSpPFLJyw+mVJ3Z44FobtV1e46rfcrvjSzZMPCVLN8TctknhyTxXyblvtyzAhd2P7BNbjtJlzXYXVm3ozm0r8mc7QgfYIWHc3vVPwOC9KWyCGUpLy5Pv8Zmal9dHbmEbmSbIvjEbrKjYF85IIXzI7N/d13T+Jc1eY+a1xlaYHJDXdAoK/RkTOm2orfIcClMJQ4b66yRGb8FM0EPBGKZFscbejC1aHnazyj0bUbBuMrTQZDx2rZOB69u66Drqv4vevJluLjvKEsUQHXJVdVx9NpImmSbXC0QX9w6VJ5kep6KEyFfgQC5onRsnf5s1gHgy6v+BoRTMwymBLeG0o2Yo00JtZUh9BEOJItcLSh6y8C1hhHuuuxBrNYnu6jtSRGse9uOOiyiq/dYrEcQZ43tM3nJZVL4wO394p1j9IkW+BIWV9iWZ7qeoyY2s7Sn+YH3SsBvfX0STjo3IovcZXxzv4txxtaru1Mrn1p74kRSZFsgSNlPXpWSNXunfhsOIUTXfFDvdqKr/BZZYvucm9iMl4yBte+BMklcibZAseYdZJkWLvtcK/1fDylZarih3rhoHMrvnQb2Uf1nMrxJm7d/wn49iVIHhEQn+T3c6SsWw8JJlTtHonP7BrgSMt0xQ/13qv48q2Kn+NNXPx2Jt++zCcC8iLZAkfKOlXCUajaPRHYz+mNrvhzxqDLeyUa8ZfvR3K8iYv69TPevvSFJsKRbIGjDZ7QOknyXLvniLr9bElq2dV+bND2Hj9tlhx62m7JXASQ94bTt+ONty99oYlwJFvgaD32V189Zk+yePrnRb0bxCMYjsS9gUpqhfBUMOhX2lTFxwPKzfXcQ1/em7QMuDrIaV+C0EQ4ki1wtKPwA3Aitw8o/iLreHkMEJ63qTCLBkbLRu1rcBKTqx304My/QI1Vh54ddpTzTpp4bziBdmZO+xKEJsKRbIHjtQd+bWef5NXdnLxh+vEo0XSfoSXwBOrQgkb+7jAsrmIr55i8QC6RY6/C91E4bzjRmNTzQi9GJE2yDY4C/+OBcJb31MZE4YpfB8lPoyFIwCthMKYFg5/xFNy+BKuxVMzeLLBHocubr7299iopFLw3nJU9o31pJUYkTbINjr4/K0fPvihBSR/9JqWlTi9adOZfXfD9Z95T0hmn4pw3nIX819riRFIkW+Fo7ZGe/gCP9ovSaqfi5AAAAABJRU5ErkJggg==" class="display-math" style="margin:0; vertical-align:-1px;" /> we will need to rely on <img width="260" alt="total &lt; a \lor total &lt; b \lor total &lt; carry" height="15" src="data:image/png;base64,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" class="display-math" style="margin:0; vertical-align:-4px;" /> as a reliable test for overflow, which fortunately still works.</p>
<p>Running this code shows that it takes <code>3.1 seconds</code> to run, which is fairly slow:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" title="1">$ <span class="bu">time</span> ex-vector sum-bit-vectors -i ../hw-json/corpus/bench/78mb.json -i ../hw-json/corpus/bench/78mb.json --branchiness branchiest</a>
<a class="sourceLine" id="cb3-2" title="2"><span class="ex">3.108</span></a></code></pre></div>
<h1 id="first-optimisation-avoiding-bool">First optimisation: Avoiding Bool</h1>
<p>We can do better by avoiding the use of <code>Bool</code>, which is a <a href="https://wiki.haskell.org/Algebraic_data_type">sum type</a>.</p>
<p>Using such types are fairly risky in high-performance code because the complexity of representing them in memory makes them slow. Ideally, we would like to be able to use them and depend on the compiler to fully optimised away, but this doesn’t always happen.</p>
<p>We can see that GHC has failed to optimise away these constants by looking at GHC core, which is an intermediate representation used by the compiler for things such as optimisation.</p>
<p>We can instruct GHC to emit GHC core by invoking it with additional flags:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" title="1"><span class="ex">stack</span> build --ghc-options=<span class="st">&quot;-ddump-simpl -dsuppress-all -dsuppress-coercions&quot;</span></a></code></pre></div>
<p>The GHC core for <code>sumCarry0</code> is reproduced here:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="fu">$</span><span class="ot">wsumCarry0 ::</span> <span class="dt">Word64</span> <span class="ot">-&gt;</span> <span class="dt">Word64</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> (<span class="fu">#</span> <span class="dt">Word64</span>, <span class="dt">Bool</span> <span class="fu">#</span>)</a>
<a class="sourceLine" id="cb5-2" title="2"><span class="co">{- Arity: 3, HasNoCafRefs, Strictness: &lt;L,U(U)&gt;&lt;L,U(U)&gt;&lt;L,U&gt;,</span></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="co">    Inline: [0],</span></a>
<a class="sourceLine" id="cb5-4" title="4"><span class="co">    Unfolding: (\ (w :: Word64) (w1 :: Word64) (w2 :: Bool) -&gt;</span></a>
<a class="sourceLine" id="cb5-5" title="5"><span class="co">                let {</span></a>
<a class="sourceLine" id="cb5-6" title="6"><span class="co">                  total :: Word64</span></a>
<a class="sourceLine" id="cb5-7" title="7"><span class="co">                  = case w2 of wild {</span></a>
<a class="sourceLine" id="cb5-8" title="8"><span class="co">                      False</span></a>
<a class="sourceLine" id="cb5-9" title="9"><span class="co">                      -&gt; case w of wild1 { W64# x# -&gt;</span></a>
<a class="sourceLine" id="cb5-10" title="10"><span class="co">                        case w1 of wild2 { W64# y# -&gt; W64# (plusWord# x# y#) } }</span></a>
<a class="sourceLine" id="cb5-11" title="11"><span class="co">                      True</span></a>
<a class="sourceLine" id="cb5-12" title="12"><span class="co">                      -&gt; case w of wild1 { W64# x# -&gt;</span></a>
<a class="sourceLine" id="cb5-13" title="13"><span class="co">                        case w1 of wild2 { W64# y# -&gt;</span></a>
<a class="sourceLine" id="cb5-14" title="14"><span class="co">                        W64# (plusWord# (plusWord# x# y#) 1##) } } }</span></a>
<a class="sourceLine" id="cb5-15" title="15"><span class="co">                } in</span></a>
<a class="sourceLine" id="cb5-16" title="16"><span class="co">                (# total,</span></a>
<a class="sourceLine" id="cb5-17" title="17"><span class="co">                  case total of wild { W64# x -&gt;</span></a>
<a class="sourceLine" id="cb5-18" title="18"><span class="co">                  case w of wild1 { W64# y -&gt;</span></a>
<a class="sourceLine" id="cb5-19" title="19"><span class="co">                  case ltWord# x y of lwild {</span></a>
<a class="sourceLine" id="cb5-20" title="20"><span class="co">                    DEFAULT</span></a>
<a class="sourceLine" id="cb5-21" title="21"><span class="co">                    -&gt; case w1 of wild2 { W64# y1 -&gt;</span></a>
<a class="sourceLine" id="cb5-22" title="22"><span class="co">                        case ltWord# x y1 of lwild1 {</span></a>
<a class="sourceLine" id="cb5-23" title="23"><span class="co">                          DEFAULT</span></a>
<a class="sourceLine" id="cb5-24" title="24"><span class="co">                          -&gt; case w2 of wild3 {</span></a>
<a class="sourceLine" id="cb5-25" title="25"><span class="co">                              False -&gt; False</span></a>
<a class="sourceLine" id="cb5-26" title="26"><span class="co">                              True -&gt; tagToEnum# @ Bool (ltWord# x 1##) }</span></a>
<a class="sourceLine" id="cb5-27" title="27"><span class="co">                          1# -&gt; True } }</span></a>
<a class="sourceLine" id="cb5-28" title="28"><span class="co">                    1# -&gt; True } } } #)) -}</span></a></code></pre></div>
<p>From the dump, we can see the use of <code>True</code> and <code>False</code> values on lines <code>8</code>, <code>11</code>, <code>25</code>, and <code>26</code>.</p>
<p>Moreover, we can count the number of branch instructions in the core by looking at <code>case</code> statements that have at least two branches. These can be identified on lines <code>7</code>, <code>19</code>, <code>22</code>, and <code>24</code>, adding up to <code>4</code> branches in total.</p>
<p>We can avoid the use of the inefficient data type by replacing <code>Bool</code> with <code>Word64</code>, <code>True</code> with <code>1</code> and <code>False</code> with <code>0</code>.</p>
<p>This simple change also allows us to avoid the <code>if</code> expression previously used to component the <img width="35" alt="total" height="12" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEcAAAAYCAQAAAACYSi2AAAB30lEQVR4nMVWbRHDIAzFAhawgAUs1EIt1AIWagELWKgFLNTClgDroAlt4Xa38GdrePkgjwQh/ilaeFibeAn71ziySGEgkBcs0940CQcbe2UMJYSK4VzIDmrdbXYMJcQMON9Wa1Dv3UbHUCjrNXMWULtuo2MolHDNHAfqpdvoGOoBc8IQB8ZQTebglcM15WuH62xeQf4W1nzcoCcovHOI4gvSYI6KDcnHLEP+XW6TAAwQiIJlgbT6EQopHqCQKuLneBZ1uEPMQaNb0VVWCEjdolIpbLHr7Hyo52j4GqoWZ2DXeoNKu0pezMT5UM/ZyIHKah+PkvEsyjOkzgd6jo28qMVUefI9B3HbjfMB5uzMt6kKh2cOxf2AOcnxmRe2Kg/HHIqjzgeYY1lebEV5eOZQ3E+YszIZqOqFwjPHPXDexZzkwjIZ2MoVhxKgbzt3RVI1igA+1TbZ2ELMSijCXrCCQ9E0NHH+LZ7mS1ZSzee2p8h1xdOYblCpFXydyMi25HzKZ/kN2PLDdzsMr4XDpaiwjOPBPECJOMk+KA+YPYfjc2vUORx5SvcQHAY4r31lFo81xIlsAWjJe7iFwiBcnOYuBoDFmeH3fOxIQ9m3HybpwcCJaWquULp6cCj4p4i+Su8N+qwqSyHbipkAAAAASUVORK5CYII=" class="display-math" style="margin:0; vertical-align:-1px;" />, so we can expect also the avoid one of the branches as well (<a href="https://github.com/haskell-works/blog-examples/blob/dd02285e7ab791ec1d294cedd8affd774835ebbc/ex-vector/src/Ops/SumBitVectors/Branchy.hs">full source</a>):</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="ot">sumCarry1 ::</span> <span class="dt">Wor64</span> <span class="ot">-&gt;</span> <span class="dt">Wor64</span> <span class="ot">-&gt;</span> <span class="dt">Wor64</span> <span class="ot">-&gt;</span> (<span class="dt">Wor64</span>, <span class="dt">Wor64</span>)</a>
<a class="sourceLine" id="cb6-2" title="2">sumCarry1 a b carry <span class="fu">=</span> (total, newCarry)</a>
<a class="sourceLine" id="cb6-3" title="3">  <span class="kw">where</span> total     <span class="fu">=</span> a <span class="fu">+</span> b <span class="fu">+</span> carry</a>
<a class="sourceLine" id="cb6-4" title="4">        newCarry  <span class="fu">=</span> <span class="kw">if</span> total <span class="fu">&lt;</span> a <span class="fu">||</span> total <span class="fu">&lt;</span> b <span class="fu">||</span> total <span class="fu">&lt;</span> carry <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span></a></code></pre></div>
<p>This results in the following core:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="fu">$</span>wsumCarry</a>
<a class="sourceLine" id="cb7-2" title="2">  <span class="fu">=</span> \ w_smut w1_smuu w2_smuv <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb7-3" title="3">      <span class="kw">let</span> {</a>
<a class="sourceLine" id="cb7-4" title="4">        total_sk3O</a>
<a class="sourceLine" id="cb7-5" title="5">        total_sk3O</a>
<a class="sourceLine" id="cb7-6" title="6">          <span class="fu">=</span> <span class="kw">case</span> w_smut <span class="kw">of</span> { <span class="dt">W64</span><span class="fu">#</span> x<span class="fu">#</span>_aj6l <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb7-7" title="7">            <span class="kw">case</span> w1_smuu <span class="kw">of</span> { <span class="dt">W64</span><span class="fu">#</span> y<span class="fu">#</span>_aj6p <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb7-8" title="8">            <span class="kw">case</span> w2_smuv <span class="kw">of</span> { <span class="dt">W64</span><span class="fu">#</span> y<span class="fu">#</span><span class="dv">1</span>_Xjkx <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb7-9" title="9">            <span class="dt">W64</span><span class="fu">#</span> (plusWord<span class="fu">#</span> (plusWord<span class="fu">#</span> x<span class="fu">#</span>_aj6l y<span class="fu">#</span>_aj6p) y<span class="fu">#</span><span class="dv">1</span>_Xjkx)</a>
<a class="sourceLine" id="cb7-10" title="10">            }</a>
<a class="sourceLine" id="cb7-11" title="11">            }</a>
<a class="sourceLine" id="cb7-12" title="12">            } } <span class="kw">in</span></a>
<a class="sourceLine" id="cb7-13" title="13">      (<span class="fu">#</span> total_sk3O,</a>
<a class="sourceLine" id="cb7-14" title="14">         <span class="kw">case</span> total_sk3O <span class="kw">of</span> { <span class="dt">W64</span><span class="fu">#</span> x_aj6G <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb7-15" title="15">         <span class="kw">case</span> w_smut <span class="kw">of</span> { <span class="dt">W64</span><span class="fu">#</span> y_aj6K <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb7-16" title="16">         <span class="kw">case</span> ltWord<span class="fu">#</span> x_aj6G y_aj6K <span class="kw">of</span> {</a>
<a class="sourceLine" id="cb7-17" title="17">           __DEFAULT <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb7-18" title="18">             <span class="kw">case</span> w1_smuu <span class="kw">of</span> { <span class="dt">W64</span><span class="fu">#</span> y1_XjaA <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb7-19" title="19">             <span class="kw">case</span> ltWord<span class="fu">#</span> x_aj6G y1_XjaA <span class="kw">of</span> {</a>
<a class="sourceLine" id="cb7-20" title="20">               __DEFAULT <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb7-21" title="21">                 <span class="kw">case</span> w2_smuv <span class="kw">of</span> { <span class="dt">W64</span><span class="fu">#</span> y2_XjaJ <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb7-22" title="22">                 <span class="kw">case</span> ltWord<span class="fu">#</span> x_aj6G y2_XjaJ <span class="kw">of</span> {</a>
<a class="sourceLine" id="cb7-23" title="23">                   __DEFAULT <span class="ot">-&gt;</span> sumCarry2;</a>
<a class="sourceLine" id="cb7-24" title="24">                   <span class="dv">1</span><span class="fu">#</span> <span class="ot">-&gt;</span> sumCarry1</a>
<a class="sourceLine" id="cb7-25" title="25">                 }</a>
<a class="sourceLine" id="cb7-26" title="26">                 };</a>
<a class="sourceLine" id="cb7-27" title="27">               <span class="dv">1</span><span class="fu">#</span> <span class="ot">-&gt;</span> sumCarry1</a>
<a class="sourceLine" id="cb7-28" title="28">             }</a>
<a class="sourceLine" id="cb7-29" title="29">             };</a>
<a class="sourceLine" id="cb7-30" title="30">           <span class="dv">1</span><span class="fu">#</span> <span class="ot">-&gt;</span> sumCarry1</a>
<a class="sourceLine" id="cb7-31" title="31">         }</a>
<a class="sourceLine" id="cb7-32" title="32">         }</a>
<a class="sourceLine" id="cb7-33" title="33">         } <span class="fu">#</span>)</a></code></pre></div>
<p>The core shows three branching <code>case</code> expressions on lines <code>16</code>, <code>19</code> and <code>22</code>.</p>
<p>Assuming we have all the additional code necessary to call our function and perform the bit-vector addition (to be described later in <a href="#adding-bit-vectors">Adding bit-vectors</a>), let’s see how this performs:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb8-1" title="1">$ <span class="bu">time</span> ex-vector sum-bit-vectors -i ../hw-json/corpus/bench/78mb.json -i ../hw-json/corpus/bench/78mb.json --branchiness branchy</a>
<a class="sourceLine" id="cb8-2" title="2"><span class="ex">1.330</span></a></code></pre></div>
<p>That works out to be a performance boost of about <code>57%</code>.</p>
<h1 id="a-little-refactoring">A little refactoring</h1>
<p>We can do a little bit better by further trying to reduce the number of branches in our code.</p>
<p>But before we can do that we’re going to explore a bit of refactoring.</p>
<p>Our earlier implementation detects when an overflow has happened by using the following test <img width="260" alt="total &lt; a \lor total &lt; b \lor total &lt; carry" height="15" src="data:image/png;base64,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" class="display-math" style="margin:0; vertical-align:-4px;" />.</p>
<p>We might have tried the alternative more intuitive test of <img width="152" alt="total &lt; a + b + carry" height="15" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAATEAAAAeCAQAAADu4eG0AAAFNUlEQVR4nO1bDdWrPAzGQi3UQi1gAQtYwAIWsIAFLGBhFrCw2z+2/oQ2adn2vXw8nHveHdqQhCRNmnKb5pcQzSKvtXk240/l+ARYM2vtnvLfjZ+BNa10rqe82l+LcjqUbkOzXTJ8qtHJ+GNfomoarl3sqnhcMnyqoSJPfImqafoLp5Jrh08xhHwp25eoFKY/lEo2YhCVhw+V05/CIF/L/CUqhbNSSfcFo1AlLQ+fS6fXWao3fInqrFTSS0fdpJN9GlTDl4fPpV3sUVRTlVHVV2JMrhLKvcairQYVNMPXhM8FXUxtsdXV2RaCukKX4XKdGuXVv8yJoVIpTFHBr6ymEuOScpMO1pOoUtLkQDP8Hj7CvrXPcXojttEbx5oPjnxczxo8+vQ4B58r5P1AtEVfajV62N+u6Zl0BmVMbg0rUFSK0UMmUa7pe/3SfRcsTSVcO+dCNFxOmhxosprwURfXb2olrLQlb+VtIybdafF0S2k+SV5cZwIVFrMeUdLixlX7nMsZT69QEcfZCa6plIDuC5okQ56lMnE8OrNChypLJa3tmVONkJMmD9p8E3i7KTlpvaa7mJA2WZ38Mjnbr5Tmwo4s2obGiqNjl/Q4k/eZ/uu7lJoxwYJC3S2h05EbgW3wALgn1gZs+8ih6JVYr1WdwkUYgbw0eVAMb8LHjeyVwI/qYr6DGV67tmnNR2u5hzNrdPoD6fHB5pEu4KGsBGYYuLu1Rgozbx5MxbRQrivEDkWrxHpb2NPdCydNHhTDx89fCPQ0F2ORjbaXiXOaL3bW05slkON7upyCPPYMeL4AdbdGvdz7aL04gHtiim717sQOhU1VTNd/NftGjDR5UAwfP59yFktzsVg79jJwTnPzq4tm4cZHy813qRbwGQuoptqAe53nYnAlFtOVVmLCiclS5KXxwfW6gLkeB/04WNuYYz0n2EY0zcdMwKXH+2CRIVVixpnCOmv0UiNUicV0sUNhUxWzzYmheA3DSBOiBS5lrPguJFX8/O4wedRxSj0Zr7ly81TrOj0+B0sAqRIbgXuG4e61cCUW09VVYqyqEsNIgwE+fcXPhwqOMziln4zT3CS64wBOj8ejpEpsAgTyl3y4EpsRDkVvGvTauen7SYw0GODljRPLg8SR8mZSnz3iND+uxDDj4Si6EjNuA+Xg0RMbojJqHzmUmeMu2JQDdNMVm0nOmZcGB5qLuami1avJZ1qvqXDBaV5XiYWjiUrMPWdsLdEQPZzpvZ1IUsVsReRQ7wVbkNcTYVdX7MF3Xhoc8IYfgrnhpv48TpCNFJg2M07zukos5HFYiTVeGbjYiOPREjkH7CAqE7VvtsxpBXZOh3i0v0oO0Lk+Y8CdUOalwQFveL+XH7aqz+QE2cgc64gGp3ldJRa6uEhsPpzu8+Q4kRuPTJu1RVA1+uRyp1KHPZtVbbHshRWMJauANPa9Zr5flpMGB4rh51cxoZouNAcr6Yu58wfnI/e85nWVmHHx5fV7SW1rhN6x9VEC6rURVRJcAWMeUSmFZn26P2tler18zs6qYw5tl6I1zOWz7zVTbpaXBgOK4d8c14KeHnUjNFgbDfKt+h8H5DUfM0k8N66euVkPmVOVmBGnPVCtPRxJUQnv4x6uT+zD8XO+8+oRX13kpMmDfnJ4/NbO5aRw3DtLa84yvHLjb+7mG4zaNvn/Gt/7UPCvfpLIoz7cDRLKzxf+u5zqEB7A59ofN24Q0Xtt+MSHiDdulKFztnlqRaN82XvjBgr718cdqnl04wYZTNaN5v9sHOzP/wE74IL9r6I4+QAAAABJRU5ErkJggg==" class="display-math" style="margin:0; vertical-align:-4px;" /> instead, but sadly that does not work because as mentioned earlier, we lose the carry bit.</p>
<p>We can however make the observation that unconstrained by word sizes, the test is valid and we can use this to derive an alternative test that also works.</p>
<p>Jumping back to our first implementation the expression <img width="260" alt="total &lt; a \lor total &lt; b \lor total &lt; carry" height="15" src="data:image/png;base64,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" class="display-math" style="margin:0; vertical-align:-4px;" /> can be rewritten as <img width="198" alt="total &lt; a \verb+ max + b \verb+ max + carry" height="15" src="data:image/png;base64,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" class="display-math" style="margin:0; vertical-align:-4px;" />, where <img width="28" alt="\verb+max+" height="8" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAAQCAQAAADpcHTOAAABc0lEQVR4nKVVYdWFIAylAhWoYAUqWMEKVqCCFahABStQgQrvG9uATfEdz/e2P8gu97Ix0BgyZzy4hdFqgll4bgd3RluNk6+Il0Ys5NWs+L5gP+jRZB5t4DQqSvLk2RYLiiWL2A7fUXxrJIQb1QGhSkV0EWeaeUQkyM3Disj4YRvETp51iE+8InLVhHmxD4J5LMoH9t3MwiaKWLp1nLQk8kn33LQgVTpgeUeZnu2YEFpcU7exY3YP5kUwXPb4bGFKuWAlPB7LtbGUYDuPIAp1F3RQygPmW4vMcmgtdzs5LdiyehZ0WETyzKLzon05vfeCS+9eL5AzwYZ8LOg7wYxllyRzQQuXg87w/EXQiT7+Llhv6GqoS49b9LWgRUH91M0Ed3GpEr5a/xSk8dklLVJfy7ZgO9mO0U+FoqLO832cgLq1fmCywhKJUaX3bBIsladuy4nX9VKH8Sj7Ps5dYJyEvhYBvgPja56DvrBgEegfbPK7eWt/90Aj2v89g58AAAAASUVORK5CYII=" class="display-math" style="margin:0; vertical-align:-1px;" /> is a function that returns the largest argument. That is to say, the total is less than any of the other numbers if the total is less than the largest of them.</p>
<p>We now have two different expressions that test for carry:</p>
<ul>
<li><img width="198" alt="total &lt; a \verb+ max + b \verb+ max + carry" height="15" src="data:image/png;base64,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" class="display-math" style="margin:0; vertical-align:-4px;" /></li>
<li><img width="152" alt="total &lt; a + b + carry" height="15" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAATEAAAAeCAQAAADu4eG0AAAFNUlEQVR4nO1bDdWrPAzGQi3UQi1gAQtYwAIWsIAFLGBhFrCw2z+2/oQ2adn2vXw8nHveHdqQhCRNmnKb5pcQzSKvtXk240/l+ARYM2vtnvLfjZ+BNa10rqe82l+LcjqUbkOzXTJ8qtHJ+GNfomoarl3sqnhcMnyqoSJPfImqafoLp5Jrh08xhHwp25eoFKY/lEo2YhCVhw+V05/CIF/L/CUqhbNSSfcFo1AlLQ+fS6fXWao3fInqrFTSS0fdpJN9GlTDl4fPpV3sUVRTlVHVV2JMrhLKvcairQYVNMPXhM8FXUxtsdXV2RaCukKX4XKdGuXVv8yJoVIpTFHBr6ymEuOScpMO1pOoUtLkQDP8Hj7CvrXPcXojttEbx5oPjnxczxo8+vQ4B58r5P1AtEVfajV62N+u6Zl0BmVMbg0rUFSK0UMmUa7pe/3SfRcsTSVcO+dCNFxOmhxosprwURfXb2olrLQlb+VtIybdafF0S2k+SV5cZwIVFrMeUdLixlX7nMsZT69QEcfZCa6plIDuC5okQ56lMnE8OrNChypLJa3tmVONkJMmD9p8E3i7KTlpvaa7mJA2WZ38Mjnbr5Tmwo4s2obGiqNjl/Q4k/eZ/uu7lJoxwYJC3S2h05EbgW3wALgn1gZs+8ih6JVYr1WdwkUYgbw0eVAMb8LHjeyVwI/qYr6DGV67tmnNR2u5hzNrdPoD6fHB5pEu4KGsBGYYuLu1Rgozbx5MxbRQrivEDkWrxHpb2NPdCydNHhTDx89fCPQ0F2ORjbaXiXOaL3bW05slkON7upyCPPYMeL4AdbdGvdz7aL04gHtiim717sQOhU1VTNd/NftGjDR5UAwfP59yFktzsVg79jJwTnPzq4tm4cZHy813qRbwGQuoptqAe53nYnAlFtOVVmLCiclS5KXxwfW6gLkeB/04WNuYYz0n2EY0zcdMwKXH+2CRIVVixpnCOmv0UiNUicV0sUNhUxWzzYmheA3DSBOiBS5lrPguJFX8/O4wedRxSj0Zr7ly81TrOj0+B0sAqRIbgXuG4e61cCUW09VVYqyqEsNIgwE+fcXPhwqOMziln4zT3CS64wBOj8ejpEpsAgTyl3y4EpsRDkVvGvTauen7SYw0GODljRPLg8SR8mZSnz3iND+uxDDj4Si6EjNuA+Xg0RMbojJqHzmUmeMu2JQDdNMVm0nOmZcGB5qLuami1avJZ1qvqXDBaV5XiYWjiUrMPWdsLdEQPZzpvZ1IUsVsReRQ7wVbkNcTYVdX7MF3Xhoc8IYfgrnhpv48TpCNFJg2M07zukos5HFYiTVeGbjYiOPREjkH7CAqE7VvtsxpBXZOh3i0v0oO0Lk+Y8CdUOalwQFveL+XH7aqz+QE2cgc64gGp3ldJRa6uEhsPpzu8+Q4kRuPTJu1RVA1+uRyp1KHPZtVbbHshRWMJauANPa9Zr5flpMGB4rh51cxoZouNAcr6Yu58wfnI/e85nWVmHHx5fV7SW1rhN6x9VEC6rURVRJcAWMeUSmFZn26P2tler18zs6qYw5tl6I1zOWz7zVTbpaXBgOK4d8c14KeHnUjNFgbDfKt+h8H5DUfM0k8N66euVkPmVOVmBGnPVCtPRxJUQnv4x6uT+zD8XO+8+oRX13kpMmDfnJ4/NbO5aRw3DtLa84yvHLjb+7mG4zaNvn/Gt/7UPCvfpLIoz7cDRLKzxf+u5zqEB7A59ofN24Q0Xtt+MSHiDdulKFztnlqRaN82XvjBgr718cdqnl04wYZTNaN5v9sHOzP/wE74IL9r6I4+QAAAABJRU5ErkJggg==" class="display-math" style="margin:0; vertical-align:-4px;" /></li>
</ul>
<p>We can then make the observation that the following inequality holds:</p>
<p><img width="260" alt="a \verb+ max + b \verb+ max + carry \leq a + b + carry" height="15" src="data:image/png;base64,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" class="display-math" style="margin:0; vertical-align:-4px;" /></p>
<p>Despite them both being valid tests for a carry, they are not necessarily equal. For example when any of the values <img width="11" alt="a" height="8" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAAQCAQAAAC45EetAAAArklEQVR4nH2SURnDIAyEYwELWKgFLGChFmYBC7UQC1iYhVrAAj34ui6B0PACuQv8BIisiJQwgqmp2OgkJk+ODtoxKjKLaGJ6VozCujohQMpDabWtru/jB3O2zQnSV2UOBaWiQPqozJI4dj55c78mbhBFZV6IeZJeiPMk/YnZwpDmTRBP5qDMDk38YcWhRzfI+VgzisttzuqhhIX7j+Mut27smO/2JRtpEL32WIldL98LRarGiuWwAAAAAElFTkSuQmCC" class="display-math" style="margin:0; vertical-align:-1px;" />, <img width="10" alt="b" height="12" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAYCAQAAABQQhX9AAAAuElEQVR4nMWTURHEIAxEY6EWsIAFLGDhLGABC7VQC1jAAhZqgduUuWuHpNC/boYPmDdhWYDo1EIbJVTFGGohR4F2gHEMNhWAbo4ZYPVJv8/cYdP6tkOL7SNmE4dcBpUoI9tbhwX9TiPqwZpDf1nJumOZYdIzkBlWHewzNDooM/THipk7jEcGQlE4LHo8DF7vwmG+a4GHzjhnECTW3wP3WzWMtf0PY7HpLcafKwH26JtHL+fXy+kP9wt7+VMDJ3CWhAAAAABJRU5ErkJggg==" class="display-math" style="margin:0; vertical-align:-1px;" /> or <img width="42" alt="carry" height="11" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFUAAAAWCAQAAAAbMBgTAAACF0lEQVR4nM1XYaGEIAxeBSpQgQpWsIIVqGAFK1CBClawghV82xAYCJ737sfd/HHIN7YxPuYOoCUaLMz4TKAu2MjI0FhleUW0QFq2WP8K103LBuc7omCBDU1qHI3gUVUu28AxsqDGBIdAF3SiYUdngIhjxMP6GDf4plHnQK/S44HzTTFobE17pZBcwii0Ob05DPtIOTAn4nHO4kMy4/h4iCtEFP+WoZHO8jpQwHFeOFRGJuGITIb8bkKL3LiHuD2pMVZeaGsTXERxaJIre1JU7ESyZiqM+lPrKLTMYzwSYeGsZzkqr2KXazGjktoVWwo6hNF40XoPr7dCJ7m11PdqR/fYVp1AcCjDbwV0j0+CElG/wdSxl+yEyVqgC6ZGWav7+y7uKmZ2mDr3kn1iezFTMjVIOL5rJf4/3kme71cw3m2JLY2j7DPxf3iXqS3nUfwFy0zN3PqUqTXeram2aUixcm3ECKbmUD9lau2lw9RwUerjMeeHdSiMKPFpGFNd+JSpdbLMzTXnXcnyYzFj0bRPrKFP4ICXzJ/z0dinTA3J8mnsb645B7dxb2Px2H2RfArQcVflOLiJD8cJnfmmKj/Bga3u7J+8dJmaZeCndVAG53Nt1dwpyc20GsPnuPQfuq4OU39N9KWS/4zUrdKrwvZFCS1l7n77n6OvC/3fiDWXMrzelrUviz9zOnIV+uFAKZcWw/UYZqfs/wHcOSUdHiKxhAAAAABJRU5ErkJggg==" class="display-math" style="margin:0; vertical-align:-4px;" /> differ from each other then the expressions are not equal, but in this case, the left is less than the right.</p>
<p>We can then devise a simpler expression that we can prove evaluates to a result that lies between the two extremes and being bounded by those other expression means that it also constitutes a valid test for overflow.</p>
<p><img width="94" alt="a \lor b \lor carry" height="15" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAL0AAAAeCAQAAADTVtf7AAADpklEQVR4nO1ZgbGkIAy1BVqwBVqgBVugBVughW3BFmjBFmxhW/ASUBcQQtT9f+fv+Zyb+bdBngnhmWDTfAaiGRoL1wz/bvwqRKOavnlC6M2nH+X/xAShV59+iL+IFsRCkCNQVlri/hmun+X4WjwrcoGSUg6cZin9NY6vham4PZFhe7CU/hrH10JA8HTRillNSQFP6a9xfDEeEMASLFjL4Cj9VY4/iA42sWHVHhjALmtRlZxelV46rnJeX+EI5+gXnr14lb3tgydr3ag+uJ+2rr+l88ryLpWQY1gzCMgn7QIkSads4VX5qLxCvdLj1bo6ZiQU/SyHh3D7RjufOrgj9Ify9gFha5fXvIZR0j3JyLLizBbsKkkbWS4tdPTqGxh6rLKL05IKjcCZp+3OlnzlnuVASAjPa1kxxMNmo7yViwU77h4uhNlEkrYijy+KRRJqHJOVSJUM1Cw9njKTGUKfEV7pw3wYSaYzHIg48J5l9ZD21iyLPQWjMHADw4pi5JOiSzhsPl2EmyhUIl7ljaNisRDgcF+9J57ZkvvrDAeOGZNZn5vrNW/tMmqORkmWtQlkaY6ecm6yFRmu2hj9wqu8921Pvc3ZzzxXpO04R84jsTle89b/1e1GcayrPV0a5UQ2g2eyQvwzFmx74vtqC5bO3FZDf5wj5xFly3lryOSjrX4fDcH/C0rfOefDlxm/8o7bnnqbs5+5K23F0xz0nFxvx2JhW7fiiztW9oLS44rEecVTeo+w7am3OfuZTWkrnuag5+R56wWjJGu0NWcvpMKwo+YqPUJum5XT5uw36sTgOsbRkB9ieN6Wtbxu3duLSm+z4VDLg9axtj2cNsckG0+5HKyfPx7hoFOH5+01pU/txZo+HSgD7eOEvnObidfm9EnWpiXYOzg8yz40wrnP8/aa0qccBaX3mfcaKILmo2OFxbc9nDYn7V1VKRsucXiWVBDkcpDA8faa0qdLL6lCwm4uYRusQALs8jvvWFY72eAt07BJBvab/NPHIxw+78Ld1QPvGqy6t9eU3i+93f62VCGBjzC4czz/yU27DTKwNre//8n+YvTiGtnzH+VA9K7+x0/w+H4ImereGlIGaauHdo2gchxFpV8hYeCr2m3d6Rwfmp2PK9fxj+LHOBDKXbnlor0V5NPR1pjdn2ry3lA33ox210fc+CGkB3e1QvTG26CjMyniA8mNdwO/hq01P+4A6hvcjTfDLjnfuRrrDvwvQkAlhgcfplQj/gM3FS9l7G/ZDgAAAABJRU5ErkJggg==" class="display-math" style="margin:0; vertical-align:-4px;" /> is one such expression.</p>
<p>This means the following inequality should hold:</p>
<p><img width="374" alt="a \verb+ max + b \verb+ max + carry \leq a \lor b \lor carry \leq a + b + carry" height="15" src="data:image/png;base64,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" class="display-math" style="margin:0; vertical-align:-4px;" /></p>
<p>We know the left inequality is true because the largest addend ORed with any other number will be at least the value of the largest addend.</p>
<p>We know the right inequality to be true because we can consider two cases. If there is no overlap in the bit patterns of the addends then the LHS and the RHS end up being equal. If there is overlap, then the LHS is conceptually like a sum that has lost those bits where there is overlap in one of the registers, resulting in a value smaller than that given by an actual addition.</p>
<p>We can therefore substitute the following test instead which has fewer instructions: <img width="149" alt="total &lt; a \lor b \lor carry" height="15" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASsAAAAeCAQAAADebfCVAAAFbUlEQVR4nO1bC5GzMBCOhVjAQixgAQuxgAUsYAELWMACFmqhf14tee5uAn/vesPXuZlOw2Y37DObHGM/CcFW9dnYk00/Kse14Gwx63qqvxs/AM56ZVBP9el/WpQLoVc1sscfc5bTGJS38Q9RMdYZs/p72P+Ys5yG9jPxISrG5K9MFp2SCXYSneo6gB53lrM8vgpCvY7Hh6g05l+aLB6IVDrNlY2C5izneHwVRvVClg9RaVyVLIamWFnGhKh0B02C5izneHwVFvVCxg9RXVVZSaWAhzKsK8GVXBLg+ATTE81ZzvH4KuxNNVIb1fnKiit/3k0yuT5ZzGrmElY1WgbdWdp5fAX0plh/Brfd15/UTDoVkSb1kU6JNKrB0OR990xl1ZkksgP+ngMkTTz/sxABeyQWvZxFuLf1P3j4c4Ra8VFe7ehJ1pmnxoAeHu+y84o4unamgbeaqLO776G6ufEsqZ606hQkKqF+17sZTS3N6w7NrrWy6oxBrpUmhUkTYy1E0hmJsNZZ9Kcz72gDYmkrD4tDK1yZ0BqsB1rtrN5657YMUj0ljCQbcVy3sTtj+EPAr5h5SjWSFtF/ObNi2aFUMohFS2JEbZVV7zrYteaISZPjlDO8DqyINKybCe/5ckRu5aEhlBYOrWjzObZN0GqFG1mN3qzmJk8X8Dh3jREemZF+opC2890nYZKN73F9MEWeqo/YysSI6israZY6N5SyuDQ57JkXNQH1kIZ1Ft+PN5BTCw+N0Kgsl9cK4dVOTlu799Tk7eXh8dEZ/BDxWEuuUOo+bYlfc+/JPBU3QvnqT42orrKSrjhv2R1RpMnzfEYJjCsZ4D1vOvMKxsUWHvqZWCuPt1qx1a7uqWfwlCCOv1LhHOWoJyvsXPPdp8mE9BC9Z/1lqi34JTUiamXFTTV3Zr9HkSaPuGWJtyjTmbFTz3oeuRXxt1Kx1dpvQ/IUbXxy3EIz6jNW4pCvkR6ZXwfPrKhUrZWV8PywFbg0JUxRJMZblPl1QrzqeeS1Uh7LrXZCHAsel1EwqaysrAHFv05e4qNRpUZEray4aySMzbGKIk2Zu2/SeIsynXkop4dGHvCc1NVurNTcoIwvkatXVlZT9tftbatUqnOVFT9VWVGkKcNvWeItynTmXBFxjgc8J221NomVHRUeT0crK6s5I5If1vNUC8GI6ntW0phz/T6QIk0Z4i0npUWZpo6dwKuOBwMvCdJWW66sKOPxKLmyOjabqUiTJ3ieagWMyD7jB+aaQ2rbtVqqDBKXBqO3q6W0KKcoGfQmduDpu4YH7Ba01Z6rrOJRoLLyz/X6N9GYTM/NrkyAVDFbkRjREZgFOW4cs9kYSj1cxqWBMZgAT2tRjlG0ibfhV/DIaUWDG9XSVnuusop5FCsrFpR1xwWzLgmGS8AwT9UHbLnXqhu8ru3kvrUcUnem0087EcSlwaBblpQWZdxTD9vGV/HIacUeqQhGW+25yio2awFtSo5e8BzYqe9/3CizJ1Ct7xfEzUHLwy1tdeyFE4yDGR7Ga4+I97MwaTBIk8poJri805hujdBvIdTwsG7p62H0Ln3jqz1XWVmzXt/fV2hTIsxOS2aSizSq0yluS1RYotILWswJur04K02YXLzoYg9J16ZY5fN57REh08Klwbg8yDc1D15bVbethofG6LQymnrM54SvdkJSMzau53w4m1igysqK0xdL4b44VqYSwUWZzpyKx+PX3JOShNsMmDQYh5prigJ4k1fx0LBayb1DeLUckQ4bP7jbuw1n29U3bkTokj7ZjRvViA+5sVbFjRsESOafcQKX927coGPwtmc6ckF3X2/cION1M3cgNXdu3CCBqx2r/b+Fwl76HylqjI3UKJyZAAAAAElFTkSuQmCC" class="display-math" style="margin:0; vertical-align:-4px;" /></p>
<p>This results in the following implementation:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="ot">sumCarry2 ::</span> <span class="dt">Word64</span> <span class="ot">-&gt;</span> <span class="dt">Word64</span> <span class="ot">-&gt;</span> <span class="dt">Word64</span> <span class="ot">-&gt;</span> (<span class="dt">Word64</span>, <span class="dt">Word64</span>)</a>
<a class="sourceLine" id="cb9-2" title="2">sumCarry2 a b carry <span class="fu">=</span> (total, newCarry)</a>
<a class="sourceLine" id="cb9-3" title="3">  <span class="kw">where</span> total     <span class="fu">=</span> a <span class="fu">+</span> b <span class="fu">+</span> carry</a>
<a class="sourceLine" id="cb9-4" title="4">        newCarry  <span class="fu">=</span> <span class="kw">if</span> total <span class="fu">&lt;</span> a <span class="fu">.|.</span> b <span class="fu">.|.</span> carry <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span></a></code></pre></div>
<p>In practise the impact of reducing the implementation by two instructions is too small to make an observable difference.</p>
<p>But the latter technique is used in the <a href="https://wiki.haskell.org/Unboxed_type"><code>hw-dsv</code></a> library, so it needed some explanation.</p>
<p>Unfortunately both version involve an <code>if</code> statement and on modern CPU architectures because of pipelining, there is a performance penalty for these kinds of branches. We would like to be able to avoid them if we can.</p>
<h1 id="branchless-tests">Branchless tests</h1>
<p>Let’s look back a snippet of core from the previous dump:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1">  <span class="kw">case</span> ltWord<span class="fu">#</span> x_aj6G y_aj6K <span class="kw">of</span> {</a>
<a class="sourceLine" id="cb10-2" title="2">    __DEFAULT <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb10-3" title="3">      <span class="kw">case</span> w1_smuu <span class="kw">of</span> { <span class="dt">W64</span><span class="fu">#</span> y1_XjaA <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb10-4" title="4">      <span class="kw">case</span> ltWord<span class="fu">#</span> x_aj6G y1_XjaA <span class="kw">of</span> {</a>
<a class="sourceLine" id="cb10-5" title="5">        __DEFAULT <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb10-6" title="6">          <span class="kw">case</span> w2_smuv <span class="kw">of</span> { <span class="dt">W64</span><span class="fu">#</span> y2_XjaJ <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb10-7" title="7">          <span class="kw">case</span> ltWord<span class="fu">#</span> x_aj6G y2_XjaJ <span class="kw">of</span> {</a>
<a class="sourceLine" id="cb10-8" title="8">            __DEFAULT <span class="ot">-&gt;</span> sumCarry2;</a>
<a class="sourceLine" id="cb10-9" title="9">            <span class="dv">1</span><span class="fu">#</span> <span class="ot">-&gt;</span> sumCarry1</a>
<a class="sourceLine" id="cb10-10" title="10">          }</a>
<a class="sourceLine" id="cb10-11" title="11">          };</a>
<a class="sourceLine" id="cb10-12" title="12">        <span class="dv">1</span><span class="fu">#</span> <span class="ot">-&gt;</span> sumCarry1</a>
<a class="sourceLine" id="cb10-13" title="13">      }</a>
<a class="sourceLine" id="cb10-14" title="14">      };</a>
<a class="sourceLine" id="cb10-15" title="15">    <span class="dv">1</span><span class="fu">#</span> <span class="ot">-&gt;</span> sumCarry1</a></code></pre></div>
<p>One line <code>1</code>, we can see our <code>sumCarry1</code> is calling an <code>ltWord#</code> function that does not exist in our definition. This is because the <code>(&lt;)</code> operator we do use calls <code>ltWord#</code> and GHC has inlined our use of the operator.</p>
<p>The <code>ltWord#</code> function is actually what we call a primop. A special function that is implemented internally by GHC. The <code>ltWord#</code> primop behaves like <code>(&lt;)</code> except that it will return <code>1</code> instead of <code>True</code> and <code>0</code> instead of <code>False</code>.</p>
<p>Let’s check out its type:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb11-1" title="1">$ <span class="ex">stack</span> repl ex-vector:exe:ex-vector</a>
<a class="sourceLine" id="cb11-2" title="2">λ<span class="op">&gt;</span> :<span class="ex">set</span> -XMagicHash</a>
<a class="sourceLine" id="cb11-3" title="3">λ<span class="op">&gt;</span> <span class="ex">import</span> GHC.Prim</a>
<a class="sourceLine" id="cb11-4" title="4">λ<span class="op">&gt;</span> :<span class="ex">t</span> ltWord#</a>
<a class="sourceLine" id="cb11-5" title="5"><span class="ex">ltWord</span># :: Word# -<span class="op">&gt;</span> Word# -<span class="op">&gt;</span> Int#</a></code></pre></div>
<p>Notice that the primop uses the types <code>Word#</code> and <code>Int#</code>. These are <a href="https://wiki.haskell.org/Unboxed_type">unboxed values</a>, these types have less overhead than the boxed types like <code>Word64</code> or <code>Bool</code>, and GHC will optimise boxed types to unboxed types when it believes it can safely do so.</p>
<p>What we would like to do is to use the return value of <code>ltWord#</code> directly rather than test on the result and use values that are going to end up the same anyway.</p>
<p>But because it uses unboxed types, calling it directly would be inconvenient so we write a wrapper that uses boxed types and depend on GHC to optimise away our pessimisation:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1"><span class="ot">{-# LANGUAGE MagicHash #-}</span></a>
<a class="sourceLine" id="cb12-2" title="2"></a>
<a class="sourceLine" id="cb12-3" title="3"><span class="kw">import</span> <span class="dt">GHC.Int</span></a>
<a class="sourceLine" id="cb12-4" title="4"><span class="kw">import</span> <span class="dt">GHC.Prim</span></a>
<a class="sourceLine" id="cb12-5" title="5"><span class="kw">import</span> <span class="dt">GHC.Word</span> <span class="kw">hiding</span> (ltWord)</a>
<a class="sourceLine" id="cb12-6" title="6"></a>
<a class="sourceLine" id="cb12-7" title="7"><span class="ot">ltWord ::</span> <span class="dt">Word64</span> <span class="ot">-&gt;</span> <span class="dt">Word64</span> <span class="ot">-&gt;</span> <span class="dt">Word64</span></a>
<a class="sourceLine" id="cb12-8" title="8">ltWord (<span class="dt">W64</span><span class="fu">#</span> a<span class="fu">#</span>) (<span class="dt">W64</span><span class="fu">#</span> b<span class="fu">#</span>) <span class="fu">=</span> <span class="fu">fromIntegral</span> (<span class="dt">I64</span><span class="fu">#</span> (ltWord<span class="fu">#</span> a<span class="fu">#</span> b<span class="fu">#</span>))</a></code></pre></div>
<p>Notice the type signature we’ve chosen to use, which is <code>Word64 -&gt; Word64 -&gt; Word64</code> instead of <code>Word64 -&gt; Word64 -&gt; Bool</code>.</p>
<p>Such tests are called branchless comparisons.</p>
<p>We can then define a version of <code>sumCarry3</code>, the moral equivalent of <code>sumCarry1</code> except without an <code>if</code> statement:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" title="1"><span class="ot">sumCarry3 ::</span> <span class="dt">Word64</span> <span class="ot">-&gt;</span> <span class="dt">Word64</span> <span class="ot">-&gt;</span> <span class="dt">Word64</span> <span class="ot">-&gt;</span> (<span class="dt">Word64</span>, <span class="dt">Word64</span>)</a>
<a class="sourceLine" id="cb13-2" title="2">sumCarry3 a b carry <span class="fu">=</span> (total, newCarry)</a>
<a class="sourceLine" id="cb13-3" title="3">  <span class="kw">where</span> preTotal  <span class="fu">=</span> a <span class="fu">+</span> b</a>
<a class="sourceLine" id="cb13-4" title="4">        total     <span class="fu">=</span> preTotal <span class="fu">+</span> carry</a>
<a class="sourceLine" id="cb13-5" title="5">        newCarry  <span class="fu">=</span> total <span class="ot">`ltWord`</span> (a <span class="fu">.|.</span> b <span class="fu">.|.</span> carry)</a></code></pre></div>
<p>Or alternatively a <code>sumCarry4</code>, the moral equivalent of <code>sumCarry2</code>, which has fewer instructions.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" title="1"><span class="ot">sumCarry3 ::</span> <span class="dt">Word64</span> <span class="ot">-&gt;</span> <span class="dt">Word64</span> <span class="ot">-&gt;</span> <span class="dt">Word64</span> <span class="ot">-&gt;</span> (<span class="dt">Word64</span>, <span class="dt">Word64</span>)</a>
<a class="sourceLine" id="cb14-2" title="2">sumCarry3 a b carry <span class="fu">=</span> (total, newCarry)</a>
<a class="sourceLine" id="cb14-3" title="3">  <span class="kw">where</span> preTotal  <span class="fu">=</span> a <span class="fu">+</span> b</a>
<a class="sourceLine" id="cb14-4" title="4">        total     <span class="fu">=</span> preTotal <span class="fu">+</span> carry</a>
<a class="sourceLine" id="cb14-5" title="5">        newCarry  <span class="fu">=</span> total <span class="ot">`ltWord`</span> (a <span class="fu">.|.</span> b <span class="fu">.|.</span> carry)</a></code></pre></div>
<h1 id="benchmarks">Benchmarks</h1>
<div class="sourceCode" id="cb15"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb15-1" title="1">$ <span class="bu">time</span> ex-vector sum-bit-vectors -i ../hw-json/corpus/bench/78mb.json -i ../hw-json/corpus/bench/78mb.json --branchiness branchiest</a>
<a class="sourceLine" id="cb15-2" title="2"><span class="ex">3.108</span></a>
<a class="sourceLine" id="cb15-3" title="3"></a>
<a class="sourceLine" id="cb15-4" title="4">$ <span class="bu">time</span> ex-vector sum-bit-vectors -i ../hw-json/corpus/bench/78mb.json -i ../hw-json/corpus/bench/78mb.json --branchiness branchy</a>
<a class="sourceLine" id="cb15-5" title="5"><span class="ex">1.330</span></a>
<a class="sourceLine" id="cb15-6" title="6"></a>
<a class="sourceLine" id="cb15-7" title="7">$ <span class="bu">time</span> ex-vector sum-bit-vectors -i ../hw-json/corpus/bench/78mb.json -i ../hw-json/corpus/bench/78mb.json --branchiness branchless</a>
<a class="sourceLine" id="cb15-8" title="8"><span class="ex">1.065</span></a></code></pre></div>
<p>The source code for the above benchmarks can be found in the <a href="https://github.com/haskell-works/blog-examples/blob/master/ex-vector/src/Ops/SumBitVectors/Branchiest.hs">Branchiest</a>, <a href="https://github.com/haskell-works/blog-examples/blob/master/ex-vector/src/Ops/SumBitVectors/Branchy.hs">Brancy</a>, and <a href="https://github.com/haskell-works/blog-examples/blob/master/ex-vector/src/Ops/SumBitVectors/Branchless.hs">Branchless</a> modules.</p>
<h1 id="closing-remarks">Closing Remarks</h1>
<p>This post looked at how we can resegment our lazy bytestring to make the chunk sizes compatible with SIMD instructions at a reasonable cost.</p>
<p>The next post will look at using FFI to call into C functions that use SIMD to do the heavy lifting.</p>
  </section>
</article>

    </main>

    <footer>
      Site proudly generated by
      <a href="http://jaspervdj.be/hakyll">Hakyll</a>
    </footer>
  </body>
</html>
