<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Haskell Works Blog - Adding bit vectors - Branchless Comparisons</title>
    <link rel="stylesheet" href="../css/default.css" />
    <link rel="alternate" type="application/atom+xml" title="Atom - Haskell Works Blog" href="../atom.xml" />
    <link rel="alternate" type="application/rss+xml" title="RSS - Haskell Works Blog" href="../rss.xml" />
  </head>
  <body>
    <header>
      <div class="logo">
        <a href="../">Haskell Works Blog</a>
      </div>
      <nav>
        <a href="../">Home</a>
        <a href="../about.html">About</a>
        <a href="../contact.html">Contact</a>
        <a href="../archive.html">Archive</a>
        <a href="../drafts.html">Drafts</a>
      </nav>
    </header>

    <main role="main">
      <h1>Adding bit vectors - Branchless Comparisons</h1>
      <article>
  <section class="header">
    Posted on February 22, 2019
    
      by John Ky
    
  </section>
  <section>
    <p>In a <a href="../posts/2018-08-15-data-parallel-rfc-compliant-csv-parsing.html">previous post</a>, I described how addition can be used flip runs of bits, but I left the method of adding large bit-vectors unexplained.</p>
<p>This post will fill this gap by explaining how to add large bit-vectors and how to do so efficiently.</p>
<p>Examples in this post will work with examples that use vectors of <code>Word8</code> in order to be concise in the explanation, whereas the real implementation will use vectors of <code>Word64</code> for efficiency.</p>
<p>As per usual, <code>Word</code>s when expressed in binary form are expressed in <a href="https://en.wikipedia.org/wiki/Endianness">Little Endian</a>.</p>
<h1 id="overflows">Overflows</h1>
<p>CPUs perform addition on registers of finite size. We shall describe the register in question as having <img width="12" alt="n" height="8" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAQCAQAAABJ7xwgAAAAwElEQVR4nH1SUQGFIAy8ClSgghWsQAUqWMEKVrACFaxABSrwjgciyPD48bbddgOBFht22MoM2c6YxhQHVqYDy4AFJ8UaitFAJmL5lwIOkVLH4gxF7mTJXnp5lvgqSIg8IlztmaY80HNJtmWYvrq4mRu7hbGI55EXrpetvNs6qca9SYuFPHzNGH0nW8eXZPSdbOXLt7K9tIl52fLl23VvVZA3aRPPVC3bG9/EVskpzcg9t8GqY6tz9mMqccGVp5vwAwSSR4bIEK69AAAAAElFTkSuQmCC" class="display-math" style="margin:0; vertical-align:-1px;" /> bits indexed from <img width="10" alt="0" height="11" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAXCAQAAABO1swWAAAAtUlEQVR4nLVTUQ3FIAw8C1h4FrCABSzMAhZmAQuzgAUszMIs8G68l7G1LCFZdvw012u5pgBITMhIPBkzjMoeMFVi/nHECnsnXbBdOrVCAYfCS8/wijl6FsqvhgpNdHwWHnndRk75dVUqkXoW5ltpHJemB9JlXJpe6frOWGF8Bf1treQmxdZ9O8Ht5R8tjaqDJZO1EKyWI+yj+p70l2oWLC2pp9IQmA418oy6P+BsI3BziTLxpL+zvWJJAJ3IsAAAAABJRU5ErkJggg==" class="display-math" style="margin:0; vertical-align:-1px;" /> to <img width="40" alt="n - 1" height="11" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAXCAQAAAA2RQDyAAABJ0lEQVR4nO2WgQ2EIAxFuwIrsAIrsAIruIIruIIruAIrsIIruILXgnp46NXkhOOS+yQmLWhe2voDQE0S0EP3bYgzKWhhhLlOwBmXQzRXK+Aq+wf8UL8P2OJ2s0UGow5zMjvYKgawB40wkz+iYEBU6Z1pwqgCQLVs0SGNT7HkBca2BB0wgN1SJzLLccMjkUuV0VvAUCXhcXSUl7UAhg3jPT2WqaXFQV1yJM3spfAnmi+s8R5A99LgMJP65HSQvrSuOAELKJJ5UxhPFz59j1jAdN6owX1WqFgsYDpv1ODQnIZp9B1iAWkCTRSraLjtzhvziAEMExhjPCsqizSaAUw9sNleGArUT/qBsueXE6pX+5Jz+IJBvLzXBXvgmweVFIe/AXlY/uqd6gGv0J4NH/vy5gAAAABJRU5ErkJggg==" class="display-math" style="margin:0; vertical-align:-1px;" />. When adding large integers, there inevitably comes a point where the resulting integer requires more than <img width="12" alt="n" height="8" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAQCAQAAABJ7xwgAAAAwElEQVR4nH1SUQGFIAy8ClSgghWsQAUqWMEKVrACFaxABSrwjgciyPD48bbddgOBFht22MoM2c6YxhQHVqYDy4AFJ8UaitFAJmL5lwIOkVLH4gxF7mTJXnp5lvgqSIg8IlztmaY80HNJtmWYvrq4mRu7hbGI55EXrpetvNs6qca9SYuFPHzNGH0nW8eXZPSdbOXLt7K9tIl52fLl23VvVZA3aRPPVC3bG9/EVskpzcg9t8GqY6tz9mMqccGVp5vwAwSSR4bIEK69AAAAAElFTkSuQmCC" class="display-math" style="margin:0; vertical-align:-1px;" /> bits to store and will not fit in the register and an overflow occurs.</p>
<p>During an overflow, the least <img width="12" alt="n" height="8" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAQCAQAAABJ7xwgAAAAwElEQVR4nH1SUQGFIAy8ClSgghWsQAUqWMEKVrACFaxABSrwjgciyPD48bbddgOBFht22MoM2c6YxhQHVqYDy4AFJ8UaitFAJmL5lwIOkVLH4gxF7mTJXnp5lvgqSIg8IlztmaY80HNJtmWYvrq4mRu7hbGI55EXrpetvNs6qca9SYuFPHzNGH0nW8eXZPSdbOXLt7K9tIl52fLl23VvVZA3aRPPVC3bG9/EVskpzcg9t8GqY6tz9mMqccGVp5vwAwSSR4bIEK69AAAAAElFTkSuQmCC" class="display-math" style="margin:0; vertical-align:-1px;" /> signifant bits of the result are stored in the target register resulting in a number that is smaller than at least one of the addends. The <img width="23" alt="n^{th}" height="15" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC4AAAAfCAQAAAAylje0AAABfUlEQVR4nK1Wbx2FIAykAhWoQAUqWIEKVqCCFaxABSpYwQq+DVAH8v4x7n14yg9u47gNheBDCgM/NYCpgVVs4hDzKDoLhBQOyPUo8k2E4t2LfRS1gjxdMXJUO2HAAtlE3s0YxTVk7ECEI/7bPJoUx3NY4Vn2kifT7aA4NR8qfoYKYuFk31L89grugoGW4ncwD05iYAEyqiv1uIRnliyfPI67svWC33ErjoeLoB5fc6DpufAX3Iq7SE49foqieqWZgQBJdSagipsceG13yJmUBm4OS2UupsroZHf5o3RHiIXUVH2JhbHHhTpOUkC2wEjZ8TQJp6qKNO0K1TkbHzfur0mopG8t+Acu54eNfyviH7yqQ6TsZKQyZFyNIE+iTEBUFsk0QpYzRN2WniPdCJUo6QzMm9l/QT701fA+6H586uu4fa6kKvXdrvK2XHFCdRHo6PkE3387IpLi9UWQdtLd6U48PW4v8pWXd8qz/v4IIMcE1OyPNdk8MvOu033HC4C7lp08z/D1AAAAAElFTkSuQmCC" class="display-math" style="margin:0; vertical-align:-1px;" /> bit, called the carry bit, would have been set to <img width="10" alt="1" height="11" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAWCAQAAABqSHSNAAAAPUlEQVR4nGNgwAYEGWYydGCVQQLGDOUMdxn+41f4HwjPAJWcIaQQBnaPKhxVOPQUKoGzwm4gjdckdAg1GQAqoT1dLNh+GwAAAABJRU5ErkJggg==" class="display-math" style="margin:0; vertical-align:-0px;" /> but due to lack of register storage is lost instead.</p>
<p>In order to perform additions on bit-vectors of greater than size <img width="12" alt="n" height="8" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAQCAQAAABJ7xwgAAAAwElEQVR4nH1SUQGFIAy8ClSgghWsQAUqWMEKVrACFaxABSrwjgciyPD48bbddgOBFht22MoM2c6YxhQHVqYDy4AFJ8UaitFAJmL5lwIOkVLH4gxF7mTJXnp5lvgqSIg8IlztmaY80HNJtmWYvrq4mRu7hbGI55EXrpetvNs6qca9SYuFPHzNGH0nW8eXZPSdbOXLt7K9tIl52fLl23VvVZA3aRPPVC3bG9/EVskpzcg9t8GqY6tz9mMqccGVp5vwAwSSR4bIEK69AAAAAElFTkSuQmCC" class="display-math" style="margin:0; vertical-align:-1px;" />, we will need to somehow perform repeated additions using register sized slices of the bit-vector, recover the carry bits and propagate them.</p>
<h1 id="recovering-the-carry">Recovering the carry</h1>
<p>As mentioned earlier, the carry bit is notionally set when there is an overflow and an overflow also results in a truncated value that is smaller than at least one of the addends.</p>
<p>We can therefore determine whether the carry bit should be set by testing for the latter condition: <img width="147" alt="total &lt; a \lor total &lt; b" height="12" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAScAAAAYCAQAAAASCPMGAAAEUUlEQVR4nN2bgbWrIAxAWYEVXIEVXMEVWKEruIIruIIruIIruEIfCfiKEgjQnveK8fxz/m+NCbchgeAX4j9FicVcq3iK8V/9aF3+kqMUM1p7mj9fJlL0BsDTXP1/u9K0/CVHsPUQe37oDib+ZLGZOi0hOsRwR7kzxy0/dCHyVLGBOi0h9DemTfPjLMyPCkm/S95xX44FoavMjXuxgTotkOlLV0474xUk/FTA3ZljQeg+zK1zsYE6LZCCtJmUoWpOx2VkwmVjw+2+HAtCdza3PoqdqNP6VMXXBuZuQHxSpPFLJyw+mVJ3Z44FobtV1e46rfcrvjSzZMPCVLN8TctknhyTxXyblvtyzAhd2P7BNbjtJlzXYXVm3ozm0r8mc7QgfYIWHc3vVPwOC9KWyCGUpLy5Pv8Zmal9dHbmEbmSbIvjEbrKjYF85IIXzI7N/d13T+Jc1eY+a1xlaYHJDXdAoK/RkTOm2orfIcClMJQ4b66yRGb8FM0EPBGKZFscbejC1aHnazyj0bUbBuMrTQZDx2rZOB69u66Drqv4vevJluLjvKEsUQHXJVdVx9NpImmSbXC0QX9w6VJ5kep6KEyFfgQC5onRsnf5s1gHgy6v+BoRTMwymBLeG0o2Yo00JtZUh9BEOJItcLSh6y8C1hhHuuuxBrNYnu6jtSRGse9uOOiyiq/dYrEcQZ43tM3nJZVL4wO394p1j9IkW+BIWV9iWZ7qeoyY2s7Sn+YH3SsBvfX0STjo3IovcZXxzv4txxtaru1Mrn1p74kRSZFsgSNlPXpWSNXunfhsOIUTXfFDvdqKr/BZZYvucm9iMl4yBte+BMklcibZAseYdZJkWLvtcK/1fDylZarih3rhoHMrvnQb2Uf1nMrxJm7d/wn49iVIHhEQn+T3c6SsWw8JJlTtHonP7BrgSMt0xQ/13qv48q2Kn+NNXPx2Jt++zCcC8iLZAkfKOlXCUajaPRHYz+mNrvhzxqDLeyUa8ZfvR3K8iYv69TPevvSFJsKRbIGjDZ7QOknyXLvniLr9bElq2dV+bND2Hj9tlhx62m7JXASQ94bTt+ONty99oYlwJFvgaD32V189Zk+yePrnRb0bxCMYjsS9gUpqhfBUMOhX2lTFxwPKzfXcQ1/em7QMuDrIaV+C0EQ4ki1wtKPwA3Aitw8o/iLreHkMEJ63qTCLBkbLRu1rcBKTqx304My/QI1Vh54ddpTzTpp4bziBdmZO+xKEJsKRbIHjtQd+bWef5NXdnLxh+vEo0XSfoSXwBOrQgkb+7jAsrmIr55i8QC6RY6/C91E4bzjRmNTzQi9GJE2yDY4C/+OBcJb31MZE4YpfB8lPoyFIwCthMKYFg5/xFNy+BKuxVMzeLLBHocubr7299iopFLw3nJU9o31pJUYkTbINjr4/K0fPvihBSR/9JqWlTi9adOZfXfD9Z95T0hmn4pw3nIX819riRFIkW+Fo7ZGe/gCP9ovSaqfi5AAAAABJRU5ErkJggg==" class="display-math" style="margin:0; vertical-align:-1px;" /></p>
<p>This allows us to write a function that returns both the <img width="35" alt="total" height="12" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEcAAAAYCAQAAAACYSi2AAAB30lEQVR4nMVWbRHDIAzFAhawgAUs1EIt1AIWagELWKgFLNTClgDroAlt4Xa38GdrePkgjwQh/ilaeFibeAn71ziySGEgkBcs0940CQcbe2UMJYSK4VzIDmrdbXYMJcQMON9Wa1Dv3UbHUCjrNXMWULtuo2MolHDNHAfqpdvoGOoBc8IQB8ZQTebglcM15WuH62xeQf4W1nzcoCcovHOI4gvSYI6KDcnHLEP+XW6TAAwQiIJlgbT6EQopHqCQKuLneBZ1uEPMQaNb0VVWCEjdolIpbLHr7Hyo52j4GqoWZ2DXeoNKu0pezMT5UM/ZyIHKah+PkvEsyjOkzgd6jo28qMVUefI9B3HbjfMB5uzMt6kKh2cOxf2AOcnxmRe2Kg/HHIqjzgeYY1lebEV5eOZQ3E+YszIZqOqFwjPHPXDexZzkwjIZ2MoVhxKgbzt3RVI1igA+1TbZ2ELMSijCXrCCQ9E0NHH+LZ7mS1ZSzee2p8h1xdOYblCpFXydyMi25HzKZ/kN2PLDdzsMr4XDpaiwjOPBPECJOMk+KA+YPYfjc2vUORx5SvcQHAY4r31lFo81xIlsAWjJe7iFwiBcnOYuBoDFmeH3fOxIQ9m3HybpwcCJaWquULp6cCj4p4i+Su8N+qwqSyHbipkAAAAASUVORK5CYII=" class="display-math" style="margin:0; vertical-align:-1px;" /> and the <img width="42" alt="carry" height="11" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFUAAAAWCAQAAAAbMBgTAAACF0lEQVR4nM1XYaGEIAxeBSpQgQpWsIIVqGAFK1CBClawghV82xAYCJ737sfd/HHIN7YxPuYOoCUaLMz4TKAu2MjI0FhleUW0QFq2WP8K103LBuc7omCBDU1qHI3gUVUu28AxsqDGBIdAF3SiYUdngIhjxMP6GDf4plHnQK/S44HzTTFobE17pZBcwii0Ob05DPtIOTAn4nHO4kMy4/h4iCtEFP+WoZHO8jpQwHFeOFRGJuGITIb8bkKL3LiHuD2pMVZeaGsTXERxaJIre1JU7ESyZiqM+lPrKLTMYzwSYeGsZzkqr2KXazGjktoVWwo6hNF40XoPr7dCJ7m11PdqR/fYVp1AcCjDbwV0j0+CElG/wdSxl+yEyVqgC6ZGWav7+y7uKmZ2mDr3kn1iezFTMjVIOL5rJf4/3kme71cw3m2JLY2j7DPxf3iXqS3nUfwFy0zN3PqUqTXeram2aUixcm3ECKbmUD9lau2lw9RwUerjMeeHdSiMKPFpGFNd+JSpdbLMzTXnXcnyYzFj0bRPrKFP4ICXzJ/z0dinTA3J8mnsb645B7dxb2Px2H2RfArQcVflOLiJD8cJnfmmKj/Bga3u7J+8dJmaZeCndVAG53Nt1dwpyc20GsPnuPQfuq4OU39N9KWS/4zUrdKrwvZFCS1l7n77n6OvC/3fiDWXMrzelrUviz9zOnIV+uFAKZcWw/UYZqfs/wHcOSUdHiKxhAAAAABJRU5ErkJggg==" class="display-math" style="margin:0; vertical-align:-4px;" />:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="ot">add ::</span> <span class="dt">Wor64</span> <span class="ot">-&gt;</span> <span class="dt">Wor64</span> <span class="ot">-&gt;</span> (<span class="dt">Wor64</span>, <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb1-2" title="2">add a b <span class="fu">=</span> (total, carry)</a>
<a class="sourceLine" id="cb1-3" title="3">  <span class="kw">where</span> total <span class="fu">=</span> a <span class="fu">+</span> b</a>
<a class="sourceLine" id="cb1-4" title="4">        carry <span class="fu">=</span> <span class="kw">if</span> total <span class="fu">&lt;</span> a <span class="fu">||</span> total <span class="fu">&lt;</span> b <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span></a></code></pre></div>
<p>This is fine for adding the first two words in our bit-vector, but the addition of following pairs of words will need to incorporate the carry. This ends up being a threeway addition that includes an input carry.</p>
<p>We can write another function <code>addCarry</code> to perform a threeway addition (<a href="https://github.com/haskell-works/blog-examples/blob/f2d3024960cc1645078a5952dfbf70d62a21b480/ex-vector/src/Ops/SumBitVectors/Word64/Branchiest.hs">full source</a>).</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="ot">addCarry ::</span> <span class="dt">Word64</span> <span class="ot">-&gt;</span> <span class="dt">Word64</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> (<span class="dt">Word64</span>, <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb2-2" title="2">addCarry a b c <span class="fu">=</span> (t, carry0 <span class="fu">||</span> carry1)</a>
<a class="sourceLine" id="cb2-3" title="3">  <span class="kw">where</span> (s, carry0) <span class="fu">=</span> add a b</a>
<a class="sourceLine" id="cb2-4" title="4">        (t, carry1) <span class="fu">=</span> add s (<span class="kw">if</span> c <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span>)</a></code></pre></div>
<p><code>addCarry</code> is implemented by calling <code>add</code> to add the first two numbers and then converting the carry to a <code>1</code> or <code>0</code> and adding that in also.</p>
<p>Running this code shows that it takes <code>3.1 seconds</code> to run, which is fairly slow:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" title="1">$ <span class="bu">time</span> ex-vector sum-bit-vectors -i ../hw-json/corpus/bench/78mb.json -i ../hw-json/corpus/bench/78mb.json --branchiness branchiest</a>
<a class="sourceLine" id="cb3-2" title="2"><span class="ex">3.674</span></a></code></pre></div>
<h1 id="first-optimisation-avoiding-bool">First optimisation: Avoiding Bool</h1>
<p>We can do better by avoiding the use of <code>Bool</code>, which is a <a href="https://wiki.haskell.org/Algebraic_data_type">sum type</a>.</p>
<p>Using such types are fairly risky in high-performance code because the complexity of representing them in memory makes them slow. Ideally, we would like to be able to use them and depend on the compiler to fully optimised them away, but this doesn’t always happen.</p>
<p>We can see that GHC has failed to optimise away these constants by looking at GHC core. GHC core is an intermediate representation used by the compiler for things such as optimisation.</p>
<p>We can instruct GHC to emit GHC core by invoking it with additional flags:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" title="1"><span class="ex">stack</span> build --ghc-options=<span class="st">&quot;-ddump-simpl -dsuppress-all -dsuppress-coercions&quot;</span></a></code></pre></div>
<p>The GHC core for <code>addCarry</code> is reproduced here:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="fu">$</span><span class="ot">waddCarry ::</span> <span class="dt">GHC.Word.Word64</span> <span class="ot">-&gt;</span> <span class="dt">GHC.Word.Word64</span> <span class="ot">-&gt;</span> <span class="dt">GHC.Types.Bool</span> <span class="ot">-&gt;</span> (<span class="fu">#</span> <span class="dt">GHC.Word.Word64</span>, <span class="dt">GHC.Types.Bool</span> <span class="fu">#</span>)</a>
<a class="sourceLine" id="cb5-2" title="2"><span class="co">{- Arity: 3, HasNoCafRefs, Strictness: &lt;L,U(U)&gt;&lt;L,U(U)&gt;&lt;L,1*U&gt;,</span></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="co">    Inline: [0],</span></a>
<a class="sourceLine" id="cb5-4" title="4"><span class="co">    Unfolding: (\ (w :: GHC.Word.Word64)</span></a>
<a class="sourceLine" id="cb5-5" title="5"><span class="co">                  (w1 :: GHC.Word.Word64)</span></a>
<a class="sourceLine" id="cb5-6" title="6"><span class="co">                  (w2 :: GHC.Types.Bool) -&gt;</span></a>
<a class="sourceLine" id="cb5-7" title="7"><span class="co">                let {</span></a>
<a class="sourceLine" id="cb5-8" title="8"><span class="co">                  total :: GHC.Word.Word64</span></a>
<a class="sourceLine" id="cb5-9" title="9"><span class="co">                  = case w of wild { GHC.Word.W64# x# -&gt;</span></a>
<a class="sourceLine" id="cb5-10" title="10"><span class="co">                    case w1 of wild1 { GHC.Word.W64# y# -&gt;</span></a>
<a class="sourceLine" id="cb5-11" title="11"><span class="co">                    GHC.Word.W64# (GHC.Prim.plusWord# x# y#) } }</span></a>
<a class="sourceLine" id="cb5-12" title="12"><span class="co">                } in</span></a>
<a class="sourceLine" id="cb5-13" title="13"><span class="co">                let {</span></a>
<a class="sourceLine" id="cb5-14" title="14"><span class="co">                  b :: GHC.Word.Word64</span></a>
<a class="sourceLine" id="cb5-15" title="15"><span class="co">                  = case w2 of wild {</span></a>
<a class="sourceLine" id="cb5-16" title="16"><span class="co">                      GHC.Types.False -&gt; Ops.SumBitVectors.Word64.Branchiest.addCarry2</span></a>
<a class="sourceLine" id="cb5-17" title="17"><span class="co">                      GHC.Types.True -&gt; Ops.SumBitVectors.Word64.Branchiest.addCarry1 }</span></a>
<a class="sourceLine" id="cb5-18" title="18"><span class="co">                } in</span></a>
<a class="sourceLine" id="cb5-19" title="19"><span class="co">                let {</span></a>
<a class="sourceLine" id="cb5-20" title="20"><span class="co">                  total1 :: GHC.Word.Word64</span></a>
<a class="sourceLine" id="cb5-21" title="21"><span class="co">                  = case total of wild { GHC.Word.W64# x# -&gt;</span></a>
<a class="sourceLine" id="cb5-22" title="22"><span class="co">                    case b of wild1 { GHC.Word.W64# y# -&gt;</span></a>
<a class="sourceLine" id="cb5-23" title="23"><span class="co">                    GHC.Word.W64# (GHC.Prim.plusWord# x# y#) } }</span></a>
<a class="sourceLine" id="cb5-24" title="24"><span class="co">                } in</span></a>
<a class="sourceLine" id="cb5-25" title="25"><span class="co">                (# total1,</span></a>
<a class="sourceLine" id="cb5-26" title="26"><span class="co">                  case total of wild { GHC.Word.W64# x -&gt;</span></a>
<a class="sourceLine" id="cb5-27" title="27"><span class="co">                  case w of wild1 { GHC.Word.W64# y -&gt;</span></a>
<a class="sourceLine" id="cb5-28" title="28"><span class="co">                  case GHC.Prim.ltWord# x y of lwild {</span></a>
<a class="sourceLine" id="cb5-29" title="29"><span class="co">                    DEFAULT</span></a>
<a class="sourceLine" id="cb5-30" title="30"><span class="co">                    -&gt; case w1 of wild2 { GHC.Word.W64# y1 -&gt;</span></a>
<a class="sourceLine" id="cb5-31" title="31"><span class="co">                        case GHC.Prim.ltWord# x y1 of lwild1 {</span></a>
<a class="sourceLine" id="cb5-32" title="32"><span class="co">                          DEFAULT</span></a>
<a class="sourceLine" id="cb5-33" title="33"><span class="co">                          -&gt; case total1 of wild3 { GHC.Word.W64# x1 -&gt;</span></a>
<a class="sourceLine" id="cb5-34" title="34"><span class="co">                            case GHC.Prim.ltWord# x1 x of lwild2 {</span></a>
<a class="sourceLine" id="cb5-35" title="35"><span class="co">                              DEFAULT</span></a>
<a class="sourceLine" id="cb5-36" title="36"><span class="co">                              -&gt; case b of wild4 { GHC.Word.W64# y2 -&gt;</span></a>
<a class="sourceLine" id="cb5-37" title="37"><span class="co">                                  GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.ltWord# x1 y2) }</span></a>
<a class="sourceLine" id="cb5-38" title="38"><span class="co">                              1# -&gt; GHC.Types.True } }</span></a>
<a class="sourceLine" id="cb5-39" title="39"><span class="co">                          1# -&gt; GHC.Types.True } }</span></a>
<a class="sourceLine" id="cb5-40" title="40"><span class="co">                    1# -&gt; GHC.Types.True } } } #)) -}</span></a></code></pre></div>
<p>We can see from the above dump that the <code>addCarry</code> function has nicely inlined away all the calls to <code>add</code>. We can also observe the use of <code>True</code> and <code>False</code> on lines values on lines <code>16</code>, <code>17</code>, <code>38</code>, <code>39</code>, and <code>40</code>.</p>
<p>Moreover, we can count the number of branch instructions in the core by looking at <code>case</code> statements that have at least two branches.</p>
<p>Such case statements can be identified on lines <code>15</code>, <code>28</code>, <code>31</code>, and <code>34</code>, adding up to <code>4</code> branches in <code>addCarry</code>.</p>
<p>We can avoid the use of the inefficient data type by replacing <code>Bool</code> with <code>Word64</code>, <code>True</code> with <code>1</code> and <code>False</code> with <code>0</code>.</p>
<p>This simple change also allows us to avoid the <code>if</code> expression previously used to component the <img width="35" alt="total" height="12" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEcAAAAYCAQAAAACYSi2AAAB30lEQVR4nMVWbRHDIAzFAhawgAUs1EIt1AIWagELWKgFLNTClgDroAlt4Xa38GdrePkgjwQh/ilaeFibeAn71ziySGEgkBcs0940CQcbe2UMJYSK4VzIDmrdbXYMJcQMON9Wa1Dv3UbHUCjrNXMWULtuo2MolHDNHAfqpdvoGOoBc8IQB8ZQTebglcM15WuH62xeQf4W1nzcoCcovHOI4gvSYI6KDcnHLEP+XW6TAAwQiIJlgbT6EQopHqCQKuLneBZ1uEPMQaNb0VVWCEjdolIpbLHr7Hyo52j4GqoWZ2DXeoNKu0pezMT5UM/ZyIHKah+PkvEsyjOkzgd6jo28qMVUefI9B3HbjfMB5uzMt6kKh2cOxf2AOcnxmRe2Kg/HHIqjzgeYY1lebEV5eOZQ3E+YszIZqOqFwjPHPXDexZzkwjIZ2MoVhxKgbzt3RVI1igA+1TbZ2ELMSijCXrCCQ9E0NHH+LZ7mS1ZSzee2p8h1xdOYblCpFXydyMi25HzKZ/kN2PLDdzsMr4XDpaiwjOPBPECJOMk+KA+YPYfjc2vUORx5SvcQHAY4r31lFo81xIlsAWjJe7iFwiBcnOYuBoDFmeH3fOxIQ9m3HybpwcCJaWquULp6cCj4p4i+Su8N+qwqSyHbipkAAAAASUVORK5CYII=" class="display-math" style="margin:0; vertical-align:-1px;" />, so we can expect also the avoid one of the branches as well (<a href="https://github.com/haskell-works/blog-examples/blob/f2d3024960cc1645078a5952dfbf70d62a21b480/ex-vector/src/Ops/SumBitVectors/Word64/Branchy.hs">full source</a>):</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="ot">add ::</span> <span class="dt">Word64</span> <span class="ot">-&gt;</span> <span class="dt">Word64</span> <span class="ot">-&gt;</span> (<span class="dt">Word64</span>, <span class="dt">Word64</span>)</a>
<a class="sourceLine" id="cb6-2" title="2">add a b <span class="fu">=</span> (total, newCarry)</a>
<a class="sourceLine" id="cb6-3" title="3">  <span class="kw">where</span> total     <span class="fu">=</span> a <span class="fu">+</span> b</a>
<a class="sourceLine" id="cb6-4" title="4">        newCarry  <span class="fu">=</span> <span class="kw">if</span> total <span class="fu">&lt;</span> a <span class="fu">||</span> total <span class="fu">&lt;</span> b <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb6-5" title="5"></a>
<a class="sourceLine" id="cb6-6" title="6"><span class="ot">addCarry ::</span> <span class="dt">Word64</span> <span class="ot">-&gt;</span> <span class="dt">Word64</span> <span class="ot">-&gt;</span> <span class="dt">Word64</span> <span class="ot">-&gt;</span> (<span class="dt">Word64</span>, <span class="dt">Word64</span>)</a>
<a class="sourceLine" id="cb6-7" title="7">addCarry a b c <span class="fu">=</span> (t, carry0 <span class="fu">+</span> carry1)</a>
<a class="sourceLine" id="cb6-8" title="8">  <span class="kw">where</span> (s, carry0) <span class="fu">=</span> add a b</a>
<a class="sourceLine" id="cb6-9" title="9">        (t, carry1) <span class="fu">=</span> add s c</a></code></pre></div>
<p>Notice in particular that the <code>carry0 || carry1</code> became <code>carry0 + carry1</code> rather than <code>carry0 .|. carry1</code>.</p>
<p>This is to ensure that <code>addCarry</code> behaves correctly for all possible inputs even though we never use a value of <code>c</code> other than <code>1</code> or <code>0</code>, under which circumstances either would work.</p>
<p>This results in the following core:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1">  <span class="fu">$</span><span class="ot">waddCarry ::</span></a>
<a class="sourceLine" id="cb7-2" title="2">    <span class="dt">GHC.Word.Word64</span></a>
<a class="sourceLine" id="cb7-3" title="3">    <span class="ot">-&gt;</span> <span class="dt">GHC.Word.Word64</span></a>
<a class="sourceLine" id="cb7-4" title="4">    <span class="ot">-&gt;</span> <span class="dt">GHC.Word.Word64</span></a>
<a class="sourceLine" id="cb7-5" title="5">    <span class="ot">-&gt;</span> (<span class="fu">#</span> <span class="dt">GHC.Word.Word64</span>, <span class="dt">GHC.Word.Word64</span> <span class="fu">#</span>)</a>
<a class="sourceLine" id="cb7-6" title="6">  <span class="co">{- Arity: 3, HasNoCafRefs, Strictness: &lt;L,U(U)&gt;&lt;L,U(U)&gt;&lt;L,U(U)&gt;,</span></a>
<a class="sourceLine" id="cb7-7" title="7"><span class="co">     Inline: [0],</span></a>
<a class="sourceLine" id="cb7-8" title="8"><span class="co">     Unfolding: (\ (w :: GHC.Word.Word64)</span></a>
<a class="sourceLine" id="cb7-9" title="9"><span class="co">                   (w1 :: GHC.Word.Word64)</span></a>
<a class="sourceLine" id="cb7-10" title="10"><span class="co">                   (w2 :: GHC.Word.Word64) -&gt;</span></a>
<a class="sourceLine" id="cb7-11" title="11"><span class="co">                 let {</span></a>
<a class="sourceLine" id="cb7-12" title="12"><span class="co">                   total :: GHC.Word.Word64</span></a>
<a class="sourceLine" id="cb7-13" title="13"><span class="co">                   = case w of wild { GHC.Word.W64# x# -&gt;</span></a>
<a class="sourceLine" id="cb7-14" title="14"><span class="co">                     case w1 of wild1 { GHC.Word.W64# y# -&gt;</span></a>
<a class="sourceLine" id="cb7-15" title="15"><span class="co">                     GHC.Word.W64# (GHC.Prim.plusWord# x# y#) } }</span></a>
<a class="sourceLine" id="cb7-16" title="16"><span class="co">                 } in</span></a>
<a class="sourceLine" id="cb7-17" title="17"><span class="co">                 let {</span></a>
<a class="sourceLine" id="cb7-18" title="18"><span class="co">                   total1 :: GHC.Word.Word64</span></a>
<a class="sourceLine" id="cb7-19" title="19"><span class="co">                   = case total of wild { GHC.Word.W64# x# -&gt;</span></a>
<a class="sourceLine" id="cb7-20" title="20"><span class="co">                     case w2 of wild1 { GHC.Word.W64# y# -&gt;</span></a>
<a class="sourceLine" id="cb7-21" title="21"><span class="co">                     GHC.Word.W64# (GHC.Prim.plusWord# x# y#) } }</span></a>
<a class="sourceLine" id="cb7-22" title="22"><span class="co">                 } in</span></a>
<a class="sourceLine" id="cb7-23" title="23"><span class="co">                 (# total1,</span></a>
<a class="sourceLine" id="cb7-24" title="24"><span class="co">                    case total of wild { GHC.Word.W64# x -&gt;</span></a>
<a class="sourceLine" id="cb7-25" title="25"><span class="co">                    case w of wild1 { GHC.Word.W64# y -&gt;</span></a>
<a class="sourceLine" id="cb7-26" title="26"><span class="co">                    let {</span></a>
<a class="sourceLine" id="cb7-27" title="27"><span class="co">                      $j :: GHC.Prim.Word# -&gt; GHC.Word.Word64</span></a>
<a class="sourceLine" id="cb7-28" title="28"><span class="co">                        &lt;join 1&gt; {- Arity: 1, Strictness: &lt;S,U&gt;m -}</span></a>
<a class="sourceLine" id="cb7-29" title="29"><span class="co">                      = \ (x# :: GHC.Prim.Word#)[OneShot] -&gt;</span></a>
<a class="sourceLine" id="cb7-30" title="30"><span class="co">                        case total1 of wild2 { GHC.Word.W64# x1 -&gt;</span></a>
<a class="sourceLine" id="cb7-31" title="31"><span class="co">                        case GHC.Prim.ltWord# x1 x of lwild {</span></a>
<a class="sourceLine" id="cb7-32" title="32"><span class="co">                          DEFAULT</span></a>
<a class="sourceLine" id="cb7-33" title="33"><span class="co">                          -&gt; case w2 of wild3 { GHC.Word.W64# y1 -&gt;</span></a>
<a class="sourceLine" id="cb7-34" title="34"><span class="co">                             case GHC.Prim.ltWord# x1 y1 of lwild1 {</span></a>
<a class="sourceLine" id="cb7-35" title="35"><span class="co">                               DEFAULT -&gt; GHC.Word.W64# x#</span></a>
<a class="sourceLine" id="cb7-36" title="36"><span class="co">                               1# -&gt; GHC.Word.W64# (GHC.Prim.or# x# 1##) } }</span></a>
<a class="sourceLine" id="cb7-37" title="37"><span class="co">                          1# -&gt; GHC.Word.W64# (GHC.Prim.or# x# 1##) } }</span></a>
<a class="sourceLine" id="cb7-38" title="38"><span class="co">                    } in</span></a>
<a class="sourceLine" id="cb7-39" title="39"><span class="co">                    case GHC.Prim.ltWord# x y of lwild {</span></a>
<a class="sourceLine" id="cb7-40" title="40"><span class="co">                      DEFAULT</span></a>
<a class="sourceLine" id="cb7-41" title="41"><span class="co">                      -&gt; case w1 of wild2 { GHC.Word.W64# y1 -&gt;</span></a>
<a class="sourceLine" id="cb7-42" title="42"><span class="co">                         case GHC.Prim.ltWord# x y1 of lwild1 {</span></a>
<a class="sourceLine" id="cb7-43" title="43"><span class="co">                           DEFAULT -&gt; $j 0## 1# -&gt; $j 1## } }</span></a>
<a class="sourceLine" id="cb7-44" title="44"><span class="co">                      1# -&gt; $j 1## } } } #)) -}</span></a></code></pre></div>
<p>The core shows now three branching <code>case</code> expressions on lines <code>31</code>, <code>34</code> and <code>39</code>.</p>
<p>Let’s see how this performs:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb8-1" title="1">$ <span class="bu">time</span> ex-vector sum-bit-vectors -i ../hw-json/corpus/bench/78mb.json -i ../hw-json/corpus/bench/78mb.json --branchiness branchy</a>
<a class="sourceLine" id="cb8-2" title="2"><span class="ex">1.334</span></a></code></pre></div>
<p>That works out to be a performance boost of about <code>63.7%</code>.</p>
<h1 id="branchless-tests">Branchless tests</h1>
<p>We can do a little bit better by further trying to reduce the number of branches in our code.</p>
<p>Let’s zoom in to a smaller section of the core we saw before:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1">  (<span class="fu">#</span> total1,</a>
<a class="sourceLine" id="cb9-2" title="2">    <span class="kw">case</span> total <span class="kw">of</span> wild { <span class="dt">GHC.Word.W64</span><span class="fu">#</span> x <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-3" title="3">    <span class="kw">case</span> w <span class="kw">of</span> wild1 { <span class="dt">GHC.Word.W64</span><span class="fu">#</span> y <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-4" title="4">    <span class="kw">let</span> {</a>
<a class="sourceLine" id="cb9-5" title="5">      <span class="fu">$</span><span class="ot">j ::</span> <span class="dt">GHC.Prim.Word</span><span class="fu">#</span> <span class="ot">-&gt;</span> <span class="dt">GHC.Word.Word64</span></a>
<a class="sourceLine" id="cb9-6" title="6">        <span class="fu">&lt;</span>join <span class="dv">1</span><span class="fu">&gt;</span> <span class="co">{- Arity: 1, Strictness: &lt;S,U&gt;m -}</span></a>
<a class="sourceLine" id="cb9-7" title="7">      <span class="fu">=</span> \ (x<span class="fu">#</span><span class="ot"> ::</span> <span class="dt">GHC.Prim.Word</span><span class="fu">#</span>)[<span class="dt">OneShot</span>] <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-8" title="8">        <span class="kw">case</span> total1 <span class="kw">of</span> wild2 { <span class="dt">GHC.Word.W64</span><span class="fu">#</span> x1 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-9" title="9">        <span class="kw">case</span> GHC.Prim.ltWord<span class="fu">#</span> x1 x <span class="kw">of</span> lwild {</a>
<a class="sourceLine" id="cb9-10" title="10">          <span class="dt">DEFAULT</span></a>
<a class="sourceLine" id="cb9-11" title="11">          <span class="ot">-&gt;</span> <span class="kw">case</span> w2 <span class="kw">of</span> wild3 { <span class="dt">GHC.Word.W64</span><span class="fu">#</span> y1 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-12" title="12">              <span class="kw">case</span> GHC.Prim.ltWord<span class="fu">#</span> x1 y1 <span class="kw">of</span> lwild1 {</a>
<a class="sourceLine" id="cb9-13" title="13">                <span class="dt">DEFAULT</span> <span class="ot">-&gt;</span> <span class="dt">GHC.Word.W64</span><span class="fu">#</span> x<span class="fu">#</span></a>
<a class="sourceLine" id="cb9-14" title="14">                <span class="dv">1</span><span class="fu">#</span> <span class="ot">-&gt;</span> <span class="dt">GHC.Word.W64</span><span class="fu">#</span> (GHC.Prim.or<span class="fu">#</span> x<span class="fu">#</span> <span class="dv">1</span><span class="fu">##</span>) } }</a>
<a class="sourceLine" id="cb9-15" title="15">          <span class="dv">1</span><span class="fu">#</span> <span class="ot">-&gt;</span> <span class="dt">GHC.Word.W64</span><span class="fu">#</span> (GHC.Prim.or<span class="fu">#</span> x<span class="fu">#</span> <span class="dv">1</span><span class="fu">##</span>) } }</a>
<a class="sourceLine" id="cb9-16" title="16">    } <span class="kw">in</span></a>
<a class="sourceLine" id="cb9-17" title="17">    <span class="kw">case</span> GHC.Prim.ltWord<span class="fu">#</span> x y <span class="kw">of</span> lwild {</a>
<a class="sourceLine" id="cb9-18" title="18">      <span class="dt">DEFAULT</span></a>
<a class="sourceLine" id="cb9-19" title="19">      <span class="ot">-&gt;</span> <span class="kw">case</span> w1 <span class="kw">of</span> wild2 { <span class="dt">GHC.Word.W64</span><span class="fu">#</span> y1 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-20" title="20">          <span class="kw">case</span> GHC.Prim.ltWord<span class="fu">#</span> x y1 <span class="kw">of</span> lwild1 {</a>
<a class="sourceLine" id="cb9-21" title="21">            <span class="dt">DEFAULT</span> <span class="ot">-&gt;</span> <span class="fu">$</span>j <span class="dv">0</span><span class="fu">##</span> <span class="dv">1</span><span class="fu">#</span> <span class="ot">-&gt;</span> <span class="fu">$</span>j <span class="dv">1</span><span class="fu">##</span> } }</a>
<a class="sourceLine" id="cb9-22" title="22">      <span class="dv">1</span><span class="fu">#</span> <span class="ot">-&gt;</span> <span class="fu">$</span>j <span class="dv">1</span><span class="fu">##</span> } } } <span class="fu">#</span>)) <span class="fu">-</span>}</a></code></pre></div>
<p>On lines <code>9</code>, <code>12</code> and <code>20</code> are mysterious calls to a function called <code>ltWord#</code>.</p>
<p>The <code>ltWord#</code> function is actually what we call a primop: A special function that is implemented internally by GHC. The <code>ltWord#</code> primop behaves like <code>(&lt;)</code> except that it will return <code>1#</code> instead of <code>True</code> and <code>0#</code> instead of <code>False</code>.</p>
<p>We can find this function in the <a href="https://hackage.haskell.org/package/ghc-prim-0.5.3/docs/GHC-Prim.html#v:ltWord-35-">docs</a> as having the type <code>Word# -&gt; Word# -&gt; Int#</code></p>
<p>Notice that the primop uses the types <code>Word#</code> and <code>Int#</code>. These are <a href="https://wiki.haskell.org/Unboxed_type">unboxed values</a>. These types have less overhead than the boxed types like <code>Word64</code> or <code>Bool</code>, and GHC will optimise boxed types to unboxed types when it believes it can safely do so.</p>
<p>Our performance problem lies in the fact that we whenever our compiled code calls <code>ltWord#</code> it tests against the return value for <code>DEFAULT</code> (ie. <code>0#</code>) and <code>1#</code>, whereas if we recognised that it was an integer and used it in arithmetic directly, we can avoid the branch.</p>
<p>But because <code>ltWord#</code> has unboxed types in its signature, calling it directly would be inconvenient so we write a wrapper that uses boxed types and depend on GHC to optimise away our pessimisation:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="ot">{-# LANGUAGE MagicHash #-}</span></a>
<a class="sourceLine" id="cb10-2" title="2"></a>
<a class="sourceLine" id="cb10-3" title="3"><span class="kw">import</span> <span class="dt">GHC.Int</span></a>
<a class="sourceLine" id="cb10-4" title="4"><span class="kw">import</span> <span class="dt">GHC.Prim</span></a>
<a class="sourceLine" id="cb10-5" title="5"><span class="kw">import</span> <span class="dt">GHC.Word</span> <span class="kw">hiding</span> (ltWord)</a>
<a class="sourceLine" id="cb10-6" title="6"></a>
<a class="sourceLine" id="cb10-7" title="7"><span class="ot">ltWord ::</span> <span class="dt">Word64</span> <span class="ot">-&gt;</span> <span class="dt">Word64</span> <span class="ot">-&gt;</span> <span class="dt">Word64</span></a>
<a class="sourceLine" id="cb10-8" title="8">ltWord (<span class="dt">W64</span><span class="fu">#</span> a<span class="fu">#</span>) (<span class="dt">W64</span><span class="fu">#</span> b<span class="fu">#</span>) <span class="fu">=</span> <span class="fu">fromIntegral</span> (<span class="dt">I64</span><span class="fu">#</span> (ltWord<span class="fu">#</span> a<span class="fu">#</span> b<span class="fu">#</span>))</a></code></pre></div>
<p>Notice the type signature we’ve chosen to use is <code>Word64 -&gt; Word64 -&gt; Word64</code> instead of the <code>Word64 -&gt; Word64 -&gt; Bool</code> of the <code>(&lt;)</code> operator.</p>
<p>Such tests are called branchless comparisons because a branch is not required to use the result of the comparison.</p>
<p>We can then define a version of <code>add</code> without an <code>if</code> statement:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1"><span class="ot">add ::</span> <span class="dt">Word64</span> <span class="ot">-&gt;</span> <span class="dt">Word64</span> <span class="ot">-&gt;</span> (<span class="dt">Word64</span>, <span class="dt">Word64</span>)</a>
<a class="sourceLine" id="cb11-2" title="2">add a b <span class="fu">=</span> (total, newCarry)</a>
<a class="sourceLine" id="cb11-3" title="3">  <span class="kw">where</span> total     <span class="fu">=</span> a <span class="fu">+</span> b</a>
<a class="sourceLine" id="cb11-4" title="4">        newCarry  <span class="fu">=</span> total <span class="ot">`ltWord`</span> a <span class="fu">||</span> total <span class="ot">`ltWord`</span> b</a></code></pre></div>
<p>Looking at the resulting core we see:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1"><span class="fu">$</span><span class="ot">waddCarry ::</span> <span class="dt">GHC.Word.Word64</span> <span class="ot">-&gt;</span> <span class="dt">GHC.Word.Word64</span> <span class="ot">-&gt;</span> <span class="dt">GHC.Word.Word64</span> <span class="ot">-&gt;</span> (<span class="fu">#</span> <span class="dt">GHC.Word.Word64</span>, <span class="dt">GHC.Word.Word64</span> <span class="fu">#</span>)</a>
<a class="sourceLine" id="cb12-2" title="2"><span class="co">{- Arity: 3, HasNoCafRefs, Strictness: &lt;L,U(U)&gt;&lt;L,U(U)&gt;&lt;L,U(U)&gt;,</span></a>
<a class="sourceLine" id="cb12-3" title="3"><span class="co">    Inline: [0],</span></a>
<a class="sourceLine" id="cb12-4" title="4"><span class="co">    Unfolding: (\ (w :: GHC.Word.Word64)</span></a>
<a class="sourceLine" id="cb12-5" title="5"><span class="co">                  (w1 :: GHC.Word.Word64)</span></a>
<a class="sourceLine" id="cb12-6" title="6"><span class="co">                  (w2 :: GHC.Word.Word64) -&gt;</span></a>
<a class="sourceLine" id="cb12-7" title="7"><span class="co">                let {</span></a>
<a class="sourceLine" id="cb12-8" title="8"><span class="co">                  total :: GHC.Word.Word64</span></a>
<a class="sourceLine" id="cb12-9" title="9"><span class="co">                  = case w of wild { GHC.Word.W64# x# -&gt;</span></a>
<a class="sourceLine" id="cb12-10" title="10"><span class="co">                    case w1 of wild1 { GHC.Word.W64# y# -&gt;</span></a>
<a class="sourceLine" id="cb12-11" title="11"><span class="co">                    GHC.Word.W64# (GHC.Prim.plusWord# x# y#) } }</span></a>
<a class="sourceLine" id="cb12-12" title="12"><span class="co">                } in</span></a>
<a class="sourceLine" id="cb12-13" title="13"><span class="co">                let {</span></a>
<a class="sourceLine" id="cb12-14" title="14"><span class="co">                  total1 :: GHC.Word.Word64</span></a>
<a class="sourceLine" id="cb12-15" title="15"><span class="co">                  = case total of wild { GHC.Word.W64# x# -&gt;</span></a>
<a class="sourceLine" id="cb12-16" title="16"><span class="co">                    case w2 of wild1 { GHC.Word.W64# y# -&gt;</span></a>
<a class="sourceLine" id="cb12-17" title="17"><span class="co">                    GHC.Word.W64# (GHC.Prim.plusWord# x# y#) } }</span></a>
<a class="sourceLine" id="cb12-18" title="18"><span class="co">                } in</span></a>
<a class="sourceLine" id="cb12-19" title="19"><span class="co">                (# total1,</span></a>
<a class="sourceLine" id="cb12-20" title="20"><span class="co">                  case total of wild { GHC.Word.W64# a# -&gt;</span></a>
<a class="sourceLine" id="cb12-21" title="21"><span class="co">                  case w of wild1 { GHC.Word.W64# x# -&gt;</span></a>
<a class="sourceLine" id="cb12-22" title="22"><span class="co">                  case w1 of wild2 { GHC.Word.W64# y# -&gt;</span></a>
<a class="sourceLine" id="cb12-23" title="23"><span class="co">                  case total1 of wild3 { GHC.Word.W64# a#1 -&gt;</span></a>
<a class="sourceLine" id="cb12-24" title="24"><span class="co">                  case w2 of wild4 { GHC.Word.W64# y#1 -&gt;</span></a>
<a class="sourceLine" id="cb12-25" title="25"><span class="co">                  GHC.Word.W64#</span></a>
<a class="sourceLine" id="cb12-26" title="26"><span class="co">                    (GHC.Prim.or#</span></a>
<a class="sourceLine" id="cb12-27" title="27"><span class="co">                        (GHC.Prim.int2Word# (GHC.Prim.ltWord# a# (GHC.Prim.or# x# y#)))</span></a>
<a class="sourceLine" id="cb12-28" title="28"><span class="co">                        (GHC.Prim.int2Word#</span></a>
<a class="sourceLine" id="cb12-29" title="29"><span class="co">                          (GHC.Prim.ltWord# a#1 (GHC.Prim.or# a# y#1)))) } } } } } #)) -}</span></a></code></pre></div>
<p>And we are happy to find that all the branches are gone.</p>
<p>Running this version of the code yields run in less time again:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb13-1" title="1">$ <span class="bu">time</span> ex-vector sum-bit-vectors -i ../hw-json/corpus/bench/78mb.json -i ../hw-json/corpus/bench/78mb.json --branchiness branchless</a>
<a class="sourceLine" id="cb13-2" title="2"><span class="ex">1.005</span></a></code></pre></div>
<p>This optimisation shaves another modest <code>9.0%</code> of the runtime bringing the savings to a total of <code>72.6%</code>.</p>
<h1 id="a-little-refactoring">A little refactoring</h1>
<p>Whilst we’re here, I would like to mention there is another possible implementation of the <code>add</code> function.</p>
<p>Until now, we’ve detected when an overflow has happened by using the following test <img width="147" alt="total &lt; a \lor total &lt; b" height="12" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAScAAAAYCAQAAAASCPMGAAAEUUlEQVR4nN2bgbWrIAxAWYEVXIEVXMEVWKEruIIruIIruIIruEIfCfiKEgjQnveK8fxz/m+NCbchgeAX4j9FicVcq3iK8V/9aF3+kqMUM1p7mj9fJlL0BsDTXP1/u9K0/CVHsPUQe37oDib+ZLGZOi0hOsRwR7kzxy0/dCHyVLGBOi0h9DemTfPjLMyPCkm/S95xX44FoavMjXuxgTotkOlLV0474xUk/FTA3ZljQeg+zK1zsYE6LZCCtJmUoWpOx2VkwmVjw+2+HAtCdza3PoqdqNP6VMXXBuZuQHxSpPFLJyw+mVJ3Z44FobtV1e46rfcrvjSzZMPCVLN8TctknhyTxXyblvtyzAhd2P7BNbjtJlzXYXVm3ozm0r8mc7QgfYIWHc3vVPwOC9KWyCGUpLy5Pv8Zmal9dHbmEbmSbIvjEbrKjYF85IIXzI7N/d13T+Jc1eY+a1xlaYHJDXdAoK/RkTOm2orfIcClMJQ4b66yRGb8FM0EPBGKZFscbejC1aHnazyj0bUbBuMrTQZDx2rZOB69u66Drqv4vevJluLjvKEsUQHXJVdVx9NpImmSbXC0QX9w6VJ5kep6KEyFfgQC5onRsnf5s1gHgy6v+BoRTMwymBLeG0o2Yo00JtZUh9BEOJItcLSh6y8C1hhHuuuxBrNYnu6jtSRGse9uOOiyiq/dYrEcQZ43tM3nJZVL4wO394p1j9IkW+BIWV9iWZ7qeoyY2s7Sn+YH3SsBvfX0STjo3IovcZXxzv4txxtaru1Mrn1p74kRSZFsgSNlPXpWSNXunfhsOIUTXfFDvdqKr/BZZYvucm9iMl4yBte+BMklcibZAseYdZJkWLvtcK/1fDylZarih3rhoHMrvnQb2Uf1nMrxJm7d/wn49iVIHhEQn+T3c6SsWw8JJlTtHonP7BrgSMt0xQ/13qv48q2Kn+NNXPx2Jt++zCcC8iLZAkfKOlXCUajaPRHYz+mNrvhzxqDLeyUa8ZfvR3K8iYv69TPevvSFJsKRbIGjDZ7QOknyXLvniLr9bElq2dV+bND2Hj9tlhx62m7JXASQ94bTt+ONty99oYlwJFvgaD32V189Zk+yePrnRb0bxCMYjsS9gUpqhfBUMOhX2lTFxwPKzfXcQ1/em7QMuDrIaV+C0EQ4ki1wtKPwA3Aitw8o/iLreHkMEJ63qTCLBkbLRu1rcBKTqx304My/QI1Vh54ddpTzTpp4bziBdmZO+xKEJsKRbIHjtQd+bWef5NXdnLxh+vEo0XSfoSXwBOrQgkb+7jAsrmIr55i8QC6RY6/C91E4bzjRmNTzQi9GJE2yDY4C/+OBcJb31MZE4YpfB8lPoyFIwCthMKYFg5/xFNy+BKuxVMzeLLBHocubr7299iopFLw3nJU9o31pJUYkTbINjr4/K0fPvihBSR/9JqWlTi9adOZfXfD9Z95T0hmn4pw3nIX819riRFIkW+Fo7ZGe/gCP9ovSaqfi5AAAAABJRU5ErkJggg==" class="display-math" style="margin:0; vertical-align:-1px;" />.</p>
<p>We might have tried the alternative more intuitive test of <img width="94" alt="total &lt; a + b" height="13" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALwAAAAaCAQAAACnBf7TAAADZklEQVR4nO1agZGsIAy1BVqgBVqgBVugBVuwBVugBVuwhW3BFvZDYFUkQoK7s3c3/zk3s+cSeLyEELjrum9CdbN7lu7ZjV/l8RmIzsL8nu7nh0F02kn+dI/+NpUPwM9u6FZ6WPXOU6JhoDY7CcL/XTzoYeV9pBqGaLMzP3Epvg2MsFKu4dowRKvd9Isy/MoOLEZYDa6pZVNqt2MsxSL6plXKA58pI6ysazqwKbXavSfDG+e+1Un/afCFZ4TVozHDt9ndzfDCxZMXfWwqB7jgCk8IK1/6+KePxZ1/chmli+nRPWabJsWuBxuc8p0ML53l6mQ3TLsSnzK4wr/CSkXVEEgo9WeI20f8nAoinEh+kjJOWJHslHtrXStvbYBI6pbWDC/BZTNb9BqfMrhcQ1j5R4JSy/W6vMrUnvDRbHLSy6qdSeLZZjK3ZXgdT4N8h9X41MAVPoTjy7WytLrxWlzBkj56S7t2U8VOn/K3yWTmZ3gDok+J06mo86mBJ3wIq+OWv1yNd1WLL9mQImmJ2Qnw91GgXGZehjdxG20RncanBp7wef/zVQ94LT7Cgkmhk2jB7LzVkrzJZaYudQG7yr3ahcKnBp7wef+Xt1J4pl6Rt30iPGaXW7VmeAV9cbfRM+p8jpCwyinP4/L8gM8XHRHL1EHi89sxSS65XW6Vy0xd6iKWjcONeKfwSaGRx7suf4uzyvsPHJBEiWf4EX27HJILZpdb3cvw4maGp/Cpg5Nq8v6xlA3AM/yEEEwXDWZnCTLza3gDDm+paSh86uDwHdH5oiOmmfolZd5BeDcX7eaCzKHFcSlyLtdCFW+ZLqvzoYAr/HFf0rDm0LR0vG3RG80hoyygwlBFu7O7VCbzvhQVO/JUXIf0a7E6Hwo4wg+n1hNauMRu981g3nwjszLMR3hfsdPJRAWkiCBzH4ffpRibLuUknJ6pNzV1PhRwhE/PqecDZ4L9XDUlwh59J2C6mmA3bxuJgOP9Gic6xwytIjFxcisHr3qHUt/X+FDA25Pslo59QXwpe/h6hEP5eQkbmJxPIwsySdzOT8/CTaCFqRnIefYQoeHSbb75B4y93imLX+dTB0/4fcSlNkq45MWhC99d2ankkli632T2/Xvu0Q3pprLGpwb+TaoqqPYfZPzNf0P5Bbhzdj7hH0hsKeLSQ8/hAAAAAElFTkSuQmCC" class="display-math" style="margin:0; vertical-align:-2px;" /> instead, but sadly that does not work because as mentioned earlier, we lose the carry bit.</p>
<p>We can however make the observation that unconstrained by word sizes, the test is valid and we can use this to derive an alternative test that also works.</p>
<p>Jumping back to our first implementation the expression <img width="147" alt="total &lt; a \lor total &lt; b" height="12" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAScAAAAYCAQAAAASCPMGAAAEUUlEQVR4nN2bgbWrIAxAWYEVXIEVXMEVWKEruIIruIIruIIruEIfCfiKEgjQnveK8fxz/m+NCbchgeAX4j9FicVcq3iK8V/9aF3+kqMUM1p7mj9fJlL0BsDTXP1/u9K0/CVHsPUQe37oDib+ZLGZOi0hOsRwR7kzxy0/dCHyVLGBOi0h9DemTfPjLMyPCkm/S95xX44FoavMjXuxgTotkOlLV0474xUk/FTA3ZljQeg+zK1zsYE6LZCCtJmUoWpOx2VkwmVjw+2+HAtCdza3PoqdqNP6VMXXBuZuQHxSpPFLJyw+mVJ3Z44FobtV1e46rfcrvjSzZMPCVLN8TctknhyTxXyblvtyzAhd2P7BNbjtJlzXYXVm3ozm0r8mc7QgfYIWHc3vVPwOC9KWyCGUpLy5Pv8Zmal9dHbmEbmSbIvjEbrKjYF85IIXzI7N/d13T+Jc1eY+a1xlaYHJDXdAoK/RkTOm2orfIcClMJQ4b66yRGb8FM0EPBGKZFscbejC1aHnazyj0bUbBuMrTQZDx2rZOB69u66Drqv4vevJluLjvKEsUQHXJVdVx9NpImmSbXC0QX9w6VJ5kep6KEyFfgQC5onRsnf5s1gHgy6v+BoRTMwymBLeG0o2Yo00JtZUh9BEOJItcLSh6y8C1hhHuuuxBrNYnu6jtSRGse9uOOiyiq/dYrEcQZ43tM3nJZVL4wO394p1j9IkW+BIWV9iWZ7qeoyY2s7Sn+YH3SsBvfX0STjo3IovcZXxzv4txxtaru1Mrn1p74kRSZFsgSNlPXpWSNXunfhsOIUTXfFDvdqKr/BZZYvucm9iMl4yBte+BMklcibZAseYdZJkWLvtcK/1fDylZarih3rhoHMrvnQb2Uf1nMrxJm7d/wn49iVIHhEQn+T3c6SsWw8JJlTtHonP7BrgSMt0xQ/13qv48q2Kn+NNXPx2Jt++zCcC8iLZAkfKOlXCUajaPRHYz+mNrvhzxqDLeyUa8ZfvR3K8iYv69TPevvSFJsKRbIGjDZ7QOknyXLvniLr9bElq2dV+bND2Hj9tlhx62m7JXASQ94bTt+ONty99oYlwJFvgaD32V189Zk+yePrnRb0bxCMYjsS9gUpqhfBUMOhX2lTFxwPKzfXcQ1/em7QMuDrIaV+C0EQ4ki1wtKPwA3Aitw8o/iLreHkMEJ63qTCLBkbLRu1rcBKTqx304My/QI1Vh54ddpTzTpp4bziBdmZO+xKEJsKRbIHjtQd+bWef5NXdnLxh+vEo0XSfoSXwBOrQgkb+7jAsrmIr55i8QC6RY6/C91E4bzjRmNTzQi9GJE2yDY4C/+OBcJb31MZE4YpfB8lPoyFIwCthMKYFg5/xFNy+BKuxVMzeLLBHocubr7299iopFLw3nJU9o31pJUYkTbINjr4/K0fPvihBSR/9JqWlTi9adOZfXfD9Z95T0hmn4pw3nIX819riRFIkW+Fo7ZGe/gCP9ovSaqfi5AAAAABJRU5ErkJggg==" class="display-math" style="margin:0; vertical-align:-1px;" /> can be rewritten as <img width="116" alt="total &lt; a \verb+ max + b" height="12" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOkAAAAYCAQAAAC18BLUAAAEiUlEQVR4nO1ZjZGsIAymBVqgBVqwBVuwBVuwBVuwBVqwBVuwhX0koIJEIOzO3O28C3Mze0ok5MsfQYifJC2MHat4ielH5fg2kmJBzb3s3y8jKToL5suO7qdF+SoCvY1ir3eF3tqAZC/TxiWEQkj/iE9bvSsA+pq9QBuXEMNvDB9fQAxX0Hbizl6gjQto/sukTcRwhdFOXdgLtHEBMcJHlvqmGPG9xHCFxU4d2Qu0cX0qkw7WMHYL6v9EDFfYmnJiG9f7mVRaSwU4p6bS7HupwhWgLIbR+yMFjDtEyvrhZMdwqq+GC0IicNEW9U4mVZZzt4AOLK6cNLm1YG/S82v/bLRDkd+H0SdmpryOOr++DP7nmeThCtojQopscIC3bf53qGpplQ/KU16RuooLltxsUFbIP6AgMeStmVShMRgmnCVpnumFY0F5YTjuFxaFIairf3q8i7WxBe8gTS3B/zzDdq4AQyEK67NJ0DkRVBEyzbeNPGXSIRJ1SQBsy6Sd75twTaEkTY7GE6wZmyO7B2zBJ5dkL5Ssx1bA4ueHEhj/nRn153YCHAszbTknOnhUziSo06XG8BZaQXcTlT6Tdrc8OSQA8jPpgEqYk3BXprI0Zf5DcebseElU7UHSamIPNDGQnTETAGByYDySc4WwHFyf9kKfLtdELBnNo7kkWlKo+hRAXiYdfCHEh7NOmjw5SJ1hT8GRbcsaBrVDecaHsbE4TGU3TxGHOl1OkR066iILp8+kwLdGT9Lt1YY+ifn7nbq2Rpo8hV4+3fwsv24KmsbddOgKLTtKZX/sk1M5cSee9RGkdCZN+VozqcZv8QohvjQlCpPNFPCmkCor6+yLxteDHx7FVVt7hNYkuZs0J/bkwlMUaqlMmvKlANaGPukPK2Ozj9ZIU6Iu8IxnSF0l7sbmYaX32JZF3Rp32d3+iIRE5cSJeOay6xFq6Uya8r2XSeVbmbRGmhLVQKrPSrgLZlLrHDNbjDSVnUqOSFROnAmRYjenM+lSASD/TDqgMfHr3RppSlQD6YbShTDRkEq7D5dL1+RdmSZSk+Ru4py4PLDfxaS4qLByAejmhOGD0/B3Z7mFZQxlaWrWLUGqgppYBDNTSEFncAQZRXwYrKPpVllkyqywT9t58cdEGfezF8WVmoJOALzCh2bnFO2jR22jvixNmcqQSiKjUZCGcc00FH7jLbrNZHmKFCZd41FXSXA4LCzHFSvABZpja71f/lLz1FT3Kexh1XV4y9LwvvEUeA1q6wBVovLv+tOY964ueewgNRT3iu5tn4iuDsQcgBbahEQ1dhVcAqu9gwuad7tXovFb1l4w2ZRPji+7Wrh8Xi1JUyJzVrHd+Rt4j4OKU7EregBE42ftZ/1rgq/Ad2Ddi59XrC3nbFgxE7o11mpDEtAGVBoE1ZVQ3hOXxM5lj31QJVygHezvy6vcRYB58+r6qoVzsJalydPVju/O39sJ4eUn8SFmwkuO9fTVC8DdQ7oHszl7PnazlnYgz2ufO3WPb3JcOrpsg6sllbz/zD3nUHErU5Lmc8S/LOOTftL6P28jGbxjvaxCAAAAAElFTkSuQmCC" class="display-math" style="margin:0; vertical-align:-1px;" />, where <img width="28" alt="\verb+max+" height="8" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAAQCAQAAADpcHTOAAABc0lEQVR4nKVVYdWFIAylAhWoYAUqWMEKVqCCFahABStQgQrvG9uATfEdz/e2P8gu97Ix0BgyZzy4hdFqgll4bgd3RluNk6+Il0Ys5NWs+L5gP+jRZB5t4DQqSvLk2RYLiiWL2A7fUXxrJIQb1QGhSkV0EWeaeUQkyM3Disj4YRvETp51iE+8InLVhHmxD4J5LMoH9t3MwiaKWLp1nLQk8kn33LQgVTpgeUeZnu2YEFpcU7exY3YP5kUwXPb4bGFKuWAlPB7LtbGUYDuPIAp1F3RQygPmW4vMcmgtdzs5LdiyehZ0WETyzKLzon05vfeCS+9eL5AzwYZ8LOg7wYxllyRzQQuXg87w/EXQiT7+Llhv6GqoS49b9LWgRUH91M0Ed3GpEr5a/xSk8dklLVJfy7ZgO9mO0U+FoqLO832cgLq1fmCywhKJUaX3bBIsladuy4nX9VKH8Sj7Ps5dYJyEvhYBvgPja56DvrBgEegfbPK7eWt/90Aj2v89g58AAAAASUVORK5CYII=" class="display-math" style="margin:0; vertical-align:-1px;" /> is a function that returns the largest argument. That is to say, the total is less than any of the other numbers if the total is less than the largest of them.</p>
<p>We now have two different expressions that test for overflow:</p>
<ul>
<li><img width="116" alt="total &lt; a \verb+ max + b" height="12" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOkAAAAYCAQAAAC18BLUAAAEiUlEQVR4nO1ZjZGsIAymBVqgBVqwBVuwBVuwBVuwBVqwBVuwhX0koIJEIOzO3O28C3Mze0ok5MsfQYifJC2MHat4ielH5fg2kmJBzb3s3y8jKToL5suO7qdF+SoCvY1ir3eF3tqAZC/TxiWEQkj/iE9bvSsA+pq9QBuXEMNvDB9fQAxX0Hbizl6gjQto/sukTcRwhdFOXdgLtHEBMcJHlvqmGPG9xHCFxU4d2Qu0cX0qkw7WMHYL6v9EDFfYmnJiG9f7mVRaSwU4p6bS7HupwhWgLIbR+yMFjDtEyvrhZMdwqq+GC0IicNEW9U4mVZZzt4AOLK6cNLm1YG/S82v/bLRDkd+H0SdmpryOOr++DP7nmeThCtojQopscIC3bf53qGpplQ/KU16RuooLltxsUFbIP6AgMeStmVShMRgmnCVpnumFY0F5YTjuFxaFIairf3q8i7WxBe8gTS3B/zzDdq4AQyEK67NJ0DkRVBEyzbeNPGXSIRJ1SQBsy6Sd75twTaEkTY7GE6wZmyO7B2zBJ5dkL5Ssx1bA4ueHEhj/nRn153YCHAszbTknOnhUziSo06XG8BZaQXcTlT6Tdrc8OSQA8jPpgEqYk3BXprI0Zf5DcebseElU7UHSamIPNDGQnTETAGByYDySc4WwHFyf9kKfLtdELBnNo7kkWlKo+hRAXiYdfCHEh7NOmjw5SJ1hT8GRbcsaBrVDecaHsbE4TGU3TxGHOl1OkR066iILp8+kwLdGT9Lt1YY+ifn7nbq2Rpo8hV4+3fwsv24KmsbddOgKLTtKZX/sk1M5cSee9RGkdCZN+VozqcZv8QohvjQlCpPNFPCmkCor6+yLxteDHx7FVVt7hNYkuZs0J/bkwlMUaqlMmvKlANaGPukPK2Ozj9ZIU6Iu8IxnSF0l7sbmYaX32JZF3Rp32d3+iIRE5cSJeOay6xFq6Uya8r2XSeVbmbRGmhLVQKrPSrgLZlLrHDNbjDSVnUqOSFROnAmRYjenM+lSASD/TDqgMfHr3RppSlQD6YbShTDRkEq7D5dL1+RdmSZSk+Ru4py4PLDfxaS4qLByAejmhOGD0/B3Z7mFZQxlaWrWLUGqgppYBDNTSEFncAQZRXwYrKPpVllkyqywT9t58cdEGfezF8WVmoJOALzCh2bnFO2jR22jvixNmcqQSiKjUZCGcc00FH7jLbrNZHmKFCZd41FXSXA4LCzHFSvABZpja71f/lLz1FT3Kexh1XV4y9LwvvEUeA1q6wBVovLv+tOY964ueewgNRT3iu5tn4iuDsQcgBbahEQ1dhVcAqu9gwuad7tXovFb1l4w2ZRPji+7Wrh8Xi1JUyJzVrHd+Rt4j4OKU7EregBE42ftZ/1rgq/Ad2Ddi59XrC3nbFgxE7o11mpDEtAGVBoE1ZVQ3hOXxM5lj31QJVygHezvy6vcRYB58+r6qoVzsJalydPVju/O39sJ4eUn8SFmwkuO9fTVC8DdQ7oHszl7PnazlnYgz2ufO3WPb3JcOrpsg6sllbz/zD3nUHErU5Lmc8S/LOOTftL6P28jGbxjvaxCAAAAAElFTkSuQmCC" class="display-math" style="margin:0; vertical-align:-1px;" /></li>
<li><img width="94" alt="total &lt; a + b" height="13" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALwAAAAaCAQAAACnBf7TAAADZklEQVR4nO1agZGsIAy1BVqgBVqgBVugBVuwBVugBVuwhW3BFvZDYFUkQoK7s3c3/zk3s+cSeLyEELjrum9CdbN7lu7ZjV/l8RmIzsL8nu7nh0F02kn+dI/+NpUPwM9u6FZ6WPXOU6JhoDY7CcL/XTzoYeV9pBqGaLMzP3Epvg2MsFKu4dowRKvd9Isy/MoOLEZYDa6pZVNqt2MsxSL6plXKA58pI6ysazqwKbXavSfDG+e+1Un/afCFZ4TVozHDt9ndzfDCxZMXfWwqB7jgCk8IK1/6+KePxZ1/chmli+nRPWabJsWuBxuc8p0ML53l6mQ3TLsSnzK4wr/CSkXVEEgo9WeI20f8nAoinEh+kjJOWJHslHtrXStvbYBI6pbWDC/BZTNb9BqfMrhcQ1j5R4JSy/W6vMrUnvDRbHLSy6qdSeLZZjK3ZXgdT4N8h9X41MAVPoTjy7WytLrxWlzBkj56S7t2U8VOn/K3yWTmZ3gDok+J06mo86mBJ3wIq+OWv1yNd1WLL9mQImmJ2Qnw91GgXGZehjdxG20RncanBp7wef/zVQ94LT7Cgkmhk2jB7LzVkrzJZaYudQG7yr3ahcKnBp7wef+Xt1J4pl6Rt30iPGaXW7VmeAV9cbfRM+p8jpCwyinP4/L8gM8XHRHL1EHi89sxSS65XW6Vy0xd6iKWjcONeKfwSaGRx7suf4uzyvsPHJBEiWf4EX27HJILZpdb3cvw4maGp/Cpg5Nq8v6xlA3AM/yEEEwXDWZnCTLza3gDDm+paSh86uDwHdH5oiOmmfolZd5BeDcX7eaCzKHFcSlyLtdCFW+ZLqvzoYAr/HFf0rDm0LR0vG3RG80hoyygwlBFu7O7VCbzvhQVO/JUXIf0a7E6Hwo4wg+n1hNauMRu981g3nwjszLMR3hfsdPJRAWkiCBzH4ffpRibLuUknJ6pNzV1PhRwhE/PqecDZ4L9XDUlwh59J2C6mmA3bxuJgOP9Gic6xwytIjFxcisHr3qHUt/X+FDA25Pslo59QXwpe/h6hEP5eQkbmJxPIwsySdzOT8/CTaCFqRnIefYQoeHSbb75B4y93imLX+dTB0/4fcSlNkq45MWhC99d2ankkli632T2/Xvu0Q3pprLGpwb+TaoqqPYfZPzNf0P5Bbhzdj7hH0hsKeLSQ8/hAAAAAElFTkSuQmCC" class="display-math" style="margin:0; vertical-align:-2px;" /></li>
</ul>
<p>We can then make the observation that the following inequality holds:</p>
<p><img width="119" alt="a \verb+ max + b \leq a + b" height="14" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAO4AAAAcCAQAAADMvUu7AAAD70lEQVR4nO1agbWrIAx1BVZwBVdgha7gCq7gCl3BFVjBFVzBFfpJEAShmgCv7/W3l/POebWAubmYBGzT/K8QzdQo3R767//FZ7CMIBrZDM2qaY+/bcoP4jNYPsGiactKc0n9dKyV5qqLmizfBq0m/agyU9/MGPr+ogvrsXwr9FVyUY9Pxv1Fwq5NxxxRh+Xb4V6Yi4QebYRtq9l0BX6ALWX5pijJRSDsqtsrhQXwLf5mXOZII+yoJX41uEKxWd40rZG9Glo9QqI7YHy3XRt0O659Mz+0W+Q+M4tpAOF95rna5qIO79STWUCYWwqFzfMggCsui2WniU2aotAkexxKTfAPbBOGCWhmNLQ1kHfertrvwnyxeN8N+vPkfeZlFpOLoLW6KX3fK7nkJix1IaSR70EAV1wGyz5w4cSK54OT7a7neODWGqSb8IqFxB5Kr23Yfk9bf98Ctc1jsp3E8xcYMTHryAWFsmPai8Vh7lMqbJkHAVxxySzloajumfFces+XkQQMFXh7C4HZbJepd/18KM9IdSFLGiYX3bwr8wmXLiMypFDqQa64ZJYCV4EfQLk7KCOuCQsjhmiD5ZRgqpQXbsUPmbu42HZ16ji5ndCW1J3lHuSKS2YJcszBFe4Oyl+34+HZe44x6YAOn3CJoT2ntIltT0WIEFbg3NBc7kGuuGSW61bC7ODmC+nlz9EbG4vbagfe9XVbPqVWty3HuCc2BkfbW4K4gK6gqOJ5sD2Uls/bEgTes/mfsLxFjuTvE6W3jp6LazYb1mwjcDp05WVbc4+j7YYf7UDCbocGVszge1AmGiyP+GraDjJLU9/64OcLiridq6Kl1zN1H9szJyjHto9BWXcN/kFGDQ/ywjKZ5RR15OcLirjmrNZ3WFpcoYOWyblz9N01xsj2JSMK8I4ga3iQJy6ZZRwC93g+xd2TuBbXBJLwWUiLC66CTDM04T6YBpjTz5r5hdn+VuhK4Boe5ItLYnlcBZ0Xz+uJKxI5ISUuSGrvqg4UKBgOTrpHpQ4PRuDp1PE1PMgTl8xSBqaJ7eU04EZ2CyUsKwy0Vl6BBh5Db4eZQ7g+K/stZ3hS41fx+bj6JUYND/LEZbBULhUL3Myvm2mKWGMqVwFL9z+MtdsdY4Ypk0BOtfVaXe2svFlgnhYJLMH3VEyud4dZ8xUo9SCAt/kksxR4fnvD02AwpsdwOJFD4r5rk+7/xYm5r6pwKzRiXTq753eXct3EXb3edOxs5uLzYv498zwI4InLYtnpqfcACK/ffupVNf8VHh+de3H4OpR6kP/i/TdYfpGFD/xVxeeAdyr2BQEtlnfXjb6l+eLPQLgf/py3kr3yy/EPX7PbQRuQY18AAAAASUVORK5CYII=" class="display-math" style="margin:0; vertical-align:-3px;" /></p>
<p>Despite them both being valid tests for overflow, they are not necessarily equal. For example when any of the values <img width="11" alt="a" height="8" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAAQCAQAAAC45EetAAAArklEQVR4nH2SURnDIAyEYwELWKgFLGChFmYBC7UQC1iYhVrAAj34ui6B0PACuQv8BIisiJQwgqmp2OgkJk+ODtoxKjKLaGJ6VozCujohQMpDabWtru/jB3O2zQnSV2UOBaWiQPqozJI4dj55c78mbhBFZV6IeZJeiPMk/YnZwpDmTRBP5qDMDk38YcWhRzfI+VgzisttzuqhhIX7j+Mut27smO/2JRtpEL32WIldL98LRarGiuWwAAAAAElFTkSuQmCC" class="display-math" style="margin:0; vertical-align:-1px;" /> or <img width="10" alt="b" height="12" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAYCAQAAABQQhX9AAAAuElEQVR4nMWTURHEIAxEY6EWsIAFLGDhLGABC7VQC1jAAhZqgduUuWuHpNC/boYPmDdhWYDo1EIbJVTFGGohR4F2gHEMNhWAbo4ZYPVJv8/cYdP6tkOL7SNmE4dcBpUoI9tbhwX9TiPqwZpDf1nJumOZYdIzkBlWHewzNDooM/THipk7jEcGQlE4LHo8DF7vwmG+a4GHzjhnECTW3wP3WzWMtf0PY7HpLcafKwH26JtHL+fXy+kP9wt7+VMDJ3CWhAAAAABJRU5ErkJggg==" class="display-math" style="margin:0; vertical-align:-1px;" /> differ from each other then the expressions are not equal, but in this case, the left is less than the right.</p>
<p>We can then devise a simpler expression that we can prove evaluates to a result that lies between the two extremes and being bounded by those other expression means that it also constitutes a valid test for overflow.</p>
<p><img width="37" alt="a \lor b" height="12" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEoAAAAYCAQAAAD3n6MGAAAByklEQVR4nM1WgbGDIAxlBVZgBVZgBVdgBVdgBVdwBVZwBVfoCv4kiooGgnf1+p/Xu1YheSQvzyr1G2g1qgjXAp9/A62c6tUHSIVfU7liBlLuuyENlF5XV2CTTGX/AtfX8RGKjw0q0/bvKCpUk2J7aqSHdxSlIawvPsVKlJv3iqJWDBC6hAhPy3isqA7KGppOgaE79okT6pAUZSlXud4EC2fHmdFwTk9bbXV9LIh1EES8KgovQ3M8ldXpM/GNDX13LG1TVRsCI8/7TlMWvbsMqW/q+8xoJ1S0lkjkjZ/4TJrYn+elzUlwVV56DVbRi3vyyJHvSYDbU3an1UmuJlo3TT7ywpPC12N+vlYnQRPN90lHuUY2PKmObtvbwhbkJiqZJhd5zX7bhc3Lz/vk3XQ20bpp8pEDzeIN423hk3eT3YsvmWaikEee+VyRXeg2wjKSiUqmmUidXcxRl5jRuLK3p763kOpIE7JpIvpLNYfbiJ3YHqQ0mVnc0tU9JwFNVDLNFbl/Y+aiCuMeUMN3BwWN2/36LCV4akLbAca9yRb2VAYDqYz0D2H9E+upFWNDO9L+j2ia91yTHN9ChQ6vMvCrrUorfGOdjlzsnP4BZSPRc3lIDqQAAAAASUVORK5CYII=" class="display-math" style="margin:0; vertical-align:-1px;" /> is one such expression.</p>
<p>This means the following inequality should hold:</p>
<p><img width="175" alt="a \verb+ max + b \leq a \lor b \leq a + b" height="14" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAV4AAAAcCAQAAACDxR9CAAAE9UlEQVR4nO1bgbWrIAxlBVZwBVdgha7gCq7gCl3BFVzBFVzBFfyQiCKiJGr/E9vreee0FTA3XCAEnxBPhRS1aPQ16L8n4un8EN/BcgUplChFr2lXf23KR/B0fojvYLmBTtNWF7Wl9OjvL2rrKjydH+JKlskg06SHS1oqRAtL15UuzHR7creEWTSz3RbuzO8qXMcyKRSXxEoFjPz3Bzq2jyyGZsHck/fd+YXQi5xZ4xqWyeF9MlaSujZ27N78dxxVRJxdxPq78wuBHwCcZZkozsRKEqTVf7Rjpbav2LxrZpz9Z9+dXwh8i38RL7MmdmwViUnP4627ZguNvruHFPitwRUim+VL06rYas90DQXuMPXz8bdSX/7YxvbN9Vq5D1vBy0A633mutrFSDk/anuH855tlqjvZsVQPmq55Be+oaDenwG8NrnhZLHNNzOxxpSZZQFVqgD3AVcM0P8CCWIyf+oV82/FXe28Zz3TOvVJ/r53vvMgHYyVzZbCzb6PdpcaOpQohDJ4Hm43NyDu6SUmDnw+ueBksi4VEala8UU6yfOs2BkgtG2nW8IuFghKNHrsm/VyP5V0LmrEdjMYUnK+YGjVzn9pBR9k6WUT8+JyzHcv3oAp2frYbDSPS4OeDK14yS+UlJQpmvKGc+RElZwyV8HgLCdHW3F3FVM5F4xjZRLolDIyV3CW53eGSH5jZQzjiwS4Q21Y7sTAiHX5L8MRLZilB5e4Cz82woXhxWq8ghEB0uwRDqRA5jeiSaYPF2vZm13FqPEE/s6895sFi8tncTg8hU6xWGvyW4ImXzNLIrV38ws2wueOy8ubObVRBB+QwQysIPY5sLda2h2b4JWwHH11aj3rQj/tjhxPhlu/LzwVPvGSW/bhFmsGNZ5QTv1ZO3bV4M+1AsyWx27PQ6LXbPe6JDMK3PSN0rkF+YlNz1IOV905B7HAi1PL9+GXe1nz76jYyLmSWr5VQ+HlE5YyTbfFissaajQIOLz3Hol18hm878qMl5G06qWTN+cc9uDysiB9OpMJPBS4j//WvYTvILDE/4IIfz1DEm09ZCOWUDD3HljwSNKxtr8QQ3QS54Cfyz3jQPayIHU6EW743vxmctZzMsl4V5MczFPHiWbrrsLB4pV50MOZtV/fiqFa2dwdmcd4R6hkP5pO34ocTBqnxm8ERL5nleome4416XTyIuHhxIViO9bB4jatMJFSKgTAT+ajEMk96fOM3v3UV6+BzHrSHFfHDCYP0+FlwxUti6as8d+KN68QrAzFLSLxGsvapjYgn7H2UnpPewt9q8IAdXO86/pwHX+AXyuGEQXr8LDjiJbNUC9Pk+HKywYvsFkrY0EAgYOUrwUA/NMghspFTmeWxBgXLkxg3C3Icsf80OOvBDk4maXFrivwQHPEyWDaT4yQks/vRtIa4h8UzNSM7NX02dW06DM3AbZiRazOW6sUwlZ5bMe1kQKBb3KeinkrnENX9D5zzYAG+oMogPX4IXvKVzFLC+wMveBvBGFPAElaTl+w5q6emz90k1nnULFNlFex722n+naXaj+LtndJ0zGza0+f5/Gce8SCuMNS4NT1+CJ54WSxz3fS8QJvXEz/1qjL/FUc+cqFYrrrqmUc9WDDj1tT4GfBfLP8Llj/8EMAX/lfED08B71TvBwIy2D7GL3pK6F54Or+vhhQV6TqTS/1LPJLfPyvV/sUzianMAAAAAElFTkSuQmCC" class="display-math" style="margin:0; vertical-align:-3px;" /></p>
<p>We know the left inequality is true because the largest addend ORed with any other number will be at least the value of the largest addend.</p>
<p>We know the right inequality to be true because we can consider two cases. If there is no overlap in the bit patterns of the addends then the LHS and the RHS end up being equal. If there is overlap, then the LHS is conceptually like a sum that has lost those bits where there is overlap in one of the registers, resulting in a value smaller than that given by an actual addition.</p>
<p>We can therefore substitute the following test instead which has fewer instructions: <img width="92" alt="total &lt; a \lor b" height="12" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALgAAAAYCAQAAADjJv+iAAADoElEQVR4nN1Zi7GrIBClBVqgBVqwBVugBVuwBVuwBVqwBVuwBR+7kARhYUEzkzvvOHcm17hw2M9xIUL8ElpYd23iFPNPeXwXUqy4rtP9/TFIMThXn+4afk3li4BVTeJoT6PRRUh2T3PPSgiFDv//sLenEcRGd09wz0oI8xdLz6WBZdIHhENV7JvTSLsHjx5uD6wAyx9V8INhBaJRDklHGk3u0bWH2QMrQEfpVTHeqq8y5qpDgXctIB1ptLpHpx5mD6y+peDGLf9wLv8mpONlKjOeFUHpSqP9lhbfs3qu4NLl0Y7lf+eFXcfiRi7Bum/LaEgjaGXgGkOTBlfuQOWyeHaXCctrsxrRho73EwVXWPZ7JQ8p1Nik45+FqhmY/H2lkQ7eIge3eEGm7uHz1RESI27ck36huslKu/vwNgdrg0SuAbmr4ApDZTudzbFJYQvVtzBV6dMILoU+2sr1V9JioBqbLc7lirUyl/xdM/feU/Ah7OJ6A8WxoWaiQqKq6g7wCaij54tVTHfTGks3jhJQWRirIdFnk7m3X8ENOnupvrBo8Gwo7IRWzxVtB/g0isVoK81U6qa3LBdk9CRtJTHOsWNy9/YpuAmvx35nt7Gh5zwTOZCOQ70fy0e2pVqiu+kZC+SKIcqPstV2uZO7t1XBJb41nvQiLWxopBug+oaHHrl4WkRr8UHcHSOHt1rdVXCNY/W9HvvZlDAn1Vvf8FAjq7LDKS32rk3vzpGMtFnl7m1VcBnav+l2frewKc8eB5vb8FAj+9kJK1qLZ/Lu9paRVqtnCi4fKXgLmzLiDVB9w0OPTEkygtbihaAWFwlttTa4t78HNxjo/h6lhU0Z+s2T2/AAZnKd5FxXLX45MR/A37NVK1txr38mLr2eYy/fha9doeLZcPZ+tdyGBzAn75sBq4sUw/g8ZHgTnDKyEjsGXbVKw6Qz935KT3dv7nWou9bjKp5NHSNqML/hAUxJFSxkS4GIxf5z/K6yhmq9tPW01XBZokQpsIG8n/7jhPnWsZfC3W7bSQrPhgNsgLgNz4tXPNd1g5jgsx9aLrkTx0ziMocGK/umJ3EbfoQl2qDAOhCTSTh78Opf+P6cY8PBoDC0BWd9Cw80tJWXrMYuwBClanBRIBhbtriSFSxsxbM5/1OUwYJco4z0h2H24Q8Hn/6l5nSeDTfLwW548rk2bnx/3EpjKH5XttKX41rl/lPZ9985xzYNJ4ccG26Gnh9YdMkn/wDAky6qmRZ6LQAAAABJRU5ErkJggg==" class="display-math" style="margin:0; vertical-align:-1px;" /></p>
<p>This results in the following implementation:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" title="1"><span class="ot">add ::</span> <span class="dt">Word64</span> <span class="ot">-&gt;</span> <span class="dt">Word64</span> <span class="ot">-&gt;</span> (<span class="dt">Word64</span>, <span class="dt">Word64</span>)</a>
<a class="sourceLine" id="cb14-2" title="2">add a b <span class="fu">=</span> (total, newCarry)</a>
<a class="sourceLine" id="cb14-3" title="3">  <span class="kw">where</span> total     <span class="fu">=</span> a <span class="fu">+</span> b</a>
<a class="sourceLine" id="cb14-4" title="4">        newCarry  <span class="fu">=</span> total <span class="ot">`ltWord`</span> (a <span class="fu">.|.</span> b)</a></code></pre></div>
<p>In practise the impact of reducing the implementation by this many instructions is negligable, but the latter technique is used in the <a href="https://wiki.haskell.org/Unboxed_type"><code>hw-dsv</code></a> library, so it needed some explanation.</p>
<h1 id="closing-remarks">Closing Remarks</h1>
<p>In this blog post implemented the <code>addCarry</code> and explored different implementations and evaluated various optimisation strategies such uses avoiding the boxed type <code>Bool</code> and using branchless comparisons to reduce the number of branches in the optimised code.</p>
<p>All that remains in order to perform a bit-vector addition is to invoke the <code>addCarry</code> function over all the words in the intput bit-vectors, ensuring that carries are propagated properly between adjacent additions.</p>
<p>A future blog post will look at how we can write such a function in a pure functional setting where we require mutation to populate the result bit-vector, but still want to retain the safety that immutability affords.</p>
<h1 id="appendix">Appendix</h1>
<h2 id="summary-of-benchmarks">Summary of Benchmarks</h2>
<div class="sourceCode" id="cb15"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb15-1" title="1">$ <span class="bu">time</span> ex-vector sum-bit-vectors -i ../hw-json/corpus/bench/78mb.json -i ../hw-json/corpus/bench/78mb.json --branchiness branchiest</a>
<a class="sourceLine" id="cb15-2" title="2"><span class="ex">3.674</span></a>
<a class="sourceLine" id="cb15-3" title="3"></a>
<a class="sourceLine" id="cb15-4" title="4">$ <span class="bu">time</span> ex-vector sum-bit-vectors -i ../hw-json/corpus/bench/78mb.json -i ../hw-json/corpus/bench/78mb.json --branchiness branchy</a>
<a class="sourceLine" id="cb15-5" title="5"><span class="ex">1.334</span></a>
<a class="sourceLine" id="cb15-6" title="6"></a>
<a class="sourceLine" id="cb15-7" title="7">$ <span class="bu">time</span> ex-vector sum-bit-vectors -i ../hw-json/corpus/bench/78mb.json -i ../hw-json/corpus/bench/78mb.json --branchiness branchless</a>
<a class="sourceLine" id="cb15-8" title="8"><span class="ex">1.005</span></a></code></pre></div>
<p>The source code for the above benchmarks can be found in the <a href="https://github.com/haskell-works/blog-examples/blob/f2d3024960cc1645078a5952dfbf70d62a21b480/ex-vector/src/Ops/SumBitVectors/Word64/Branchiest.hs">Branchiest</a>, <a href="https://github.com/haskell-works/blog-examples/blob/f2d3024960cc1645078a5952dfbf70d62a21b480/ex-vector/src/Ops/SumBitVectors/Word64/Branchy.hs">Branchy</a>, and <a href="https://github.com/haskell-works/blog-examples/blob/f2d3024960cc1645078a5952dfbf70d62a21b480/ex-vector/src/Ops/SumBitVectors/Word64/Branchless.hs">Branchless</a> modules.</p>
<h1 id="references">References</h1>
  </section>
</article>

    </main>

    <footer>
      Site proudly generated by
      <a href="http://jaspervdj.be/hakyll">Hakyll</a>
    </footer>
  </body>
</html>
