<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Haskell Works Blog</title>
        <link>https://haskell-works.github.io</link>
        <description><![CDATA[]]></description>
        <atom:link href="https://haskell-works.github.io/rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Wed, 08 Aug 2018 00:00:00 UT</lastBuildDate>
        <item>
    <title>Data-Parallel Rank-Select Bit-String construction</title>
    <link>https://haskell-works.github.io/posts/2018-08-08-data-parallel-rank-select-bit-string-construction.html</link>
    <description><![CDATA[<p>So far, I’ve <a href="../posts/2018-08-01-introduction-to-rank-select-bit-string.html">posted</a> about the problems with traditional parser and offered a glimpse of how they might be solved, but succinct data structures are quite alien and it isn’t obvious the pay-off will be worthwhile.</p>
<p>In this post, I demonstrate how use broadword programming techniques to exploit <a href="https://en.wikipedia.org/wiki/Data_parallelism">data-level parallelism</a> in the parsing of a CSV-like format.</p>
<p>Doing so allows us to parse the text 8-bytes at a time instead of one byte at a time as a traditional parser would.</p>
<p>For simplicity, I will be postponing the particular challenges of implementing the particulars of the <a href="https://tools.ietf.org/html/rfc4180">RFC standard for CSV</a> for a later time and instead work with a simplified format.</p>
<p>The simplified “CSV” grammar will only recognise delimiters and newlines and have no support for escaping.</p>
<p>The format I describe is effectively the kind of format that the <a href="https://en.wikipedia.org/wiki/Cut_(Unix)"><code>cut</code></a> command line tool can process, so <code>cut</code> will at some point serve as the performance baseline that I’m aiming to improve upon.</p>
<h2 id="data-parallelism">Data Parallelism</h2>
<p>Data parallelism describes a computation that can be decomposed into smaller computations that can be run in parallel.</p>
<p>We usually think of parsing is an inheritantly serial process due to the fact the parser must consume the input text one character at a time.</p>
<p>But because I’ve chosen a simplified format where the identification of delimiters and newlines are independent of what characters came before and what came after, there ought to be a way to parse the text more than one character at a time for the purposes of building a rank-select bit-string.</p>
<p>Our parser would need to generate a <code>1</code> bit for every newline in one of the rank-select bit-strings and a <code>1</code> bit for every newline and delimiter in the other.</p>
<p>Let’s use the example from the previous post to demonstrate how this can be done:</p>
<pre class="text"><code>&quot;name&quot;,&quot;age&quot;,&quot;profession&quot;␤John,30,Code Monkey␤Kyle,40,Data Scrubber
0000001000001000000000000100001001000000000001000010010000000000000
0000000000000000000000000100000000000000000001000000000000000000000</code></pre>
<p>The first line is the text we want to use to construct the following two bit-strings.</p>
<p>Note that <code>␤</code> represenes a newline ASCII character</p>
<h2 id="broadword-progamming">Broadword progamming</h2>
<p>Broadword programming, sometimes known as SWAR (SIMD Within A Register) uses large registers (in our case 64-bit integer registers) as small parallel computers that can process several pieces of information at a time.</p>
<p>We will be using this technique to parse our text 8-bytes at a time.</p>
<p>Before we start we will need the following operations:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">(.&amp;.) ::</span> <span class="dt">Word64</span> <span class="ot">-&gt;</span> <span class="dt">Word64</span> <span class="ot">-&gt;</span> <span class="dt">Word64</span> <span class="co">-- Compute the bit-wise AND of two integers</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="ot">(.|.) ::</span> <span class="dt">Word64</span> <span class="ot">-&gt;</span> <span class="dt">Word64</span> <span class="ot">-&gt;</span> <span class="dt">Word64</span> <span class="co">-- Compute the bit-wise OR of two integers</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="ot">(.^.) ::</span> <span class="dt">Word64</span> <span class="ot">-&gt;</span> <span class="dt">Word64</span> <span class="ot">-&gt;</span> <span class="dt">Word64</span> <span class="co">-- Compute the bit-wise XOR of two integers</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="ot">comp  ::</span> <span class="dt">Word64</span> <span class="ot">-&gt;</span> <span class="dt">Word64</span>           <span class="co">-- Compute the bit-wise complement of an integer</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="ot">(.&gt;.) ::</span> <span class="dt">Word64</span> <span class="ot">-&gt;</span> <span class="dt">Count</span> <span class="ot">-&gt;</span> <span class="dt">Word64</span>  <span class="co">-- Compute the right shift of an integer by the given offset in Big-Endian</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6">                                    <span class="co">-- Note, this is equivalent to a left shift of an integer in Little-Endian</span></a></code></pre></div>
<p>These operators are pretty standard, but pay close attention to the shift operator, which is the standard left shift operator.</p>
<p>When the bits are laid out in Little-Endian order the right shift operator will actually shift all the bits <em>to the LEFT</em>.</p>
<p>In all of the diagrams, bits and bytes will be laid out in Little-Endian because it is the natural layout for succinct data structures but it can be very confusing so bear with me and keep this in mind.</p>
<p>Our first task is to build the following rank-select bit-string from our text.</p>
<pre class="text"><code>&quot;name&quot;,&quot;age&quot;,&quot;profession&quot;␤John,30,Code Monkey␤Kyle,40,Data Scrubber
0000000000000000000000000100000000000000000001000000000000000000000</code></pre>
<p>To do this, we first create a 64-bit word that contains 8 x 8-bit packed integers each initialised to the ASCII code for the newline character. For example, the hexadecimal representation of the newline character is <code>0x0a</code>, so the 64-bit word we are contructing will be:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">let</span> wNewlines <span class="fu">=</span> <span class="bn">0x0101010101010101</span><span class="dt">L</span> <span class="fu">*</span> <span class="bn">0x0a</span> <span class="fu">=</span> <span class="bn">0x0a0a0a0a0a0a0a0a</span><span class="dt">L</span></a></code></pre></div>
<p>The next step is to take the text and pad it with zero bytes to the nearest 64-bit boundary. Then take the entire text and cast it to a vector of Little-Endian 64-bit integers.</p>
<p>This leads to a view of memory shown below indicated by <code>text</code>.</p>
<pre class="text"><code>             Bytes packed into Little-Endian Word64 integers
           ┌─────────────────────────┼─────────────────────────┐
┌──────────┴──────────┐   ┌──────────┴──────────┐   ┌──────────┴──────────┐
&quot;  n  a  m  e  &quot;  ,  &quot;    a  g  e  &quot;  ,  &quot;  p  r    o  f  e  s  s  i  o  n   
22 6e 61 6d 65 22 2c 22   61 67 65 22 2c 22 70 72   6f 66 65 73 73 69 6f 6e   text ─────────┐
0a 0a 0a 0a 0a 0a 0a 0a   0a 0a 0a 0a 0a 0a 0a 0a   0a 0a 0a 0a 0a 0a 0a 0a   mask ────────┐│
28 64 6b 67 6f 28 26 28   6b 6d 6f 28 26 28 7a 78   65 6c 6f 79 79 63 65 64   comparison &lt;┬┴┘ (.^.)
0  0  0  0  0  0  0  0    0  0  0  0  0  0  0  0    0  0  0  0  0  0  0  0    newlines &lt;──┘ cmpzero
                                                                            
                                                                            
  ┌──┐                                                            ┌──┐                        
&quot; │$ │J  o  h  n  ,  3    0  ,  C  o  d  e     M    o  n  k  e  y │␤ │K  y 
22│0a│4a 6f 68 6e 2c 33   30 2c 43 6f 64 65 20 4d   6f 6e 6b 65 79│0a│4b 79   text ─────────┐
0a│0a│0a 0a 0a 0a 0a 0a   0a 0a 0a 0a 0a 0a 0a 0a   0a 0a 0a 0a 0a│0a│0a 0a   mask ────────┐│
28│00│40 65 62 64 26 39   3a 26 49 65 6e 6f 2a 47   65 64 61 6f 73│00│41 73   comparison &lt;┬┴┘ (.^.)
0 │1 │0  0  0  0  0  0    0  0  0  0  0  0  0  0    0  0  0  0  0 │1 │0  0    newlines &lt;──┘ cmpzero
  └┬─┘                                                            └┬─┘  
   └──────────────────────────────────────────────┬────────────────┘
                                                  │                            
                                                  │         ┌──┐               
l  e  ,  4  0  ,  D  a    t  a     S  c  r  u  b  │ b  e  r │␤ ├───────────┐   
6c 65 2c 34 30 2c 44 61   74 61 20 53 63 72 75 62 │ 62 65 72│0a│00 00 00 00│  text ─────────┐
0a 0a 0a 0a 0a 0a 0a 0a   0a 0a 0a 0a 0a 0a 0a 0a │ 0a 0a 0a│0a│0a 0a 0a 0a│  mask ────────┐│
66 6f 26 3e 3a 26 4e 6b   7e 6b 2a 59 69 78 7f 68 │ 68 6f 78│00│0a 0a 0a 0a│  comparison &lt;┬┴┘ (.^.)
0  0  0  0  0  0  0  0    0  0  0  0  0  0  0  0  │ 0  0  0 │1 │0  0  0  0 │  newlines &lt;──┘ cmpzero
                                                  │         └┬─┴───┬───────┘  
            Bits corresponding to newlines that   │          │     └─Padding
            need to be set to 1 ──────────────────┴──────────┘</code></pre>
<p>Then for each 64-bit value in the vector take the exclusive or <code>(.^.)</code> with the <code>wNewlines</code> mask. The resulting vector of 64-bit vector when cast back to a vector of bytes will then contain a zero value for every character in the original text that was a newline and a non-zero value otherwise.</p>
<p>This is very close to what we want. All we need to do now is to collapse every non-zero byte into a <code>0</code> bit and every zero byte to a <code>1</code> bit.</p>
<p>The problem we are trying to solve can be exemplified by the following example where we need a function <code>cmpzero</code> that condenses the bytes in the <code>comparison</code> row to the bits in the <code>newlines</code> row:</p>
<pre class="text"><code>              ┌──┐
65 64 61 6f 73│00│41 73   comparison ─┐
0  0  0  0  0 │1 │0  0    newlines &lt;──┘
              └──┘</code></pre>
<p>This can be done in a series of bit-wise manipulations described below:</p>
<pre class="text"><code>T   text ┌─── 10100110 00100110 10000110 11110110 11001110 00000000 10000010 11001110
         │                                                                           
    mask │┌── 00001111 00001111 00001111 00001111 00001111 00001111 00001111 00001111
A   (.&amp;.)├┴─&gt; 00000110 00000110 00000110 00000110 00001110 00000000 00000010 00001110 ─┐    
B        │  ┌ 01100000 01100000 01100000 01100000 11100000 00000000 00100000 11100000 &lt;┘ (.&gt;. 4)
         │  └────────────────────────────────────────────────────────────────────────────┐
    mask │┌── 11110000 11110000 11110000 11110000 11110000 11110000 11110000 11110000    │
C   (.&amp;.)└┴─&gt; 10100000 00100000 10000000 11110000 11000000 00000000 10000000 11000000 ──┐│
                                                                                        ││
D        ┌─── 11100000 01100000 11100000 11110000 11100000 00000000 10100000 11100000 &lt;─┴┘(.|.)
         │                                                                             
    mask │┌── 00110000 00110000 00110000 00110000 00110000 00110000 00110000 00110000 mask 
E   (.&amp;.)├┴─&gt; 00100000 00100000 00100000 00110000 00100000 00000000 00100000 00100000 ─┐    
F        │  ┌ 10000000 10000000 10000000 11000000 10000000 00000000 10000000 10000000 &lt;┘ (.&gt;. 2)
         │  └────────────────────────────────────────────────────────────────────────────┐
G   mask │┌── 11000000 11000000 11000000 11000000 11000000 11000000 11000000 11000000    │
H   (.&amp;.)└┴─&gt; 11000000 01000000 11000000 11000000 11000000 00000000 10000000 11000000 ──┐│
                                                                                        ││
I        ┌─── 11000000 11000000 11000000 11000000 11000000 00000000 10000000 11000000 &lt;─┴┘(.|.)
         │                                                                            
    mask │┌── 01000000 01000000 01000000 01000000 01000000 00000000 01000000 01000000 
J   (.&amp;.)├┴─&gt; 01000000 01000000 01000000 01000000 01000000 00000000 01000000 01000000 ─┐    
K        │  ┌ 10000000 10000000 10000000 10000000 10000000 00000000 10000000 10000000 &lt;┘ (.&gt;. 1)
         │  └────────────────────────────────────────────────────────────────────────────┐
    mask │┌── 10000000 10000000 10000000 10000000 10000000 00000000 10000000 10000000    │
L   (.&amp;.)└┴─&gt; 10000000 10000000 10000000 10000000 10000000 00000000 10000000 10000000 ──┐│
                                                                                        ││
M             10000000 10000000 10000000 10000000 10000000 00000000 10000000 10000000 &lt;─┴┘(.|.)
              │        │        │        └───┐┌───┘        │        │        │
              │        │        └───────────┐││┌───────────┘        │        │
              │        └───────────────────┐││││┌───────────────────┘        │
              └───────────────────────────┐││││││┌───────────────────────────┘
                                          11111011─┐pext
                                          00000100&lt;┘comp</code></pre>
<p>We start with the following computations:</p>
<ul>
<li>At <code>T</code> we have our 64-bit integer that contains 8-bytes of our text</li>
<li>At <code>A</code> we mask out first half of every byte in our word <code>T</code>.</li>
<li>At <code>B</code> we shift the second half of every byte into the first half position of every byte in our word.</li>
<li>At <code>C</code> we mask out the second half of every byte in our word <code>T</code>.</li>
<li>At <code>D</code> we compute <code>A .|. C</code></li>
</ul>
<p>At this point we have compressed result into the first half of every byte. We repeat this to compress further to the first quarter of our bytes similarly:</p>
<ul>
<li>At <code>E</code> we mask out first quarter of every byte in our word <code>D</code>.</li>
<li>At <code>F</code> we shift the second quarter of every byte into the first quarter of every byte in our word.</li>
<li>At <code>H</code> we mask out the second quarter of every byte in our word <code>D</code>.</li>
<li>At <code>I</code> we compute <code>F .|. H</code></li>
</ul>
<p>Finally we do this one more time to compress the first quarter of every byte in our word to the first bit of every byte in our word.</p>
<ul>
<li>At <code>J</code> we mask out first bit of every byte in our word <code>H</code>.</li>
<li>At <code>K</code> we shift the second bit of every byte into the first bit of every byte in our word.</li>
<li>At <code>L</code> we mask out the second bit of every byte in our word <code>H</code>.</li>
<li>At <code>M</code> we compute <code>J .|. L</code></li>
</ul>
<p>Now we are two steps away from the 8-bits of rank-select bit-string we need for our 8 input characters.</p>
<p>We need some way to extract the first bit of every byte in our word, an operation I will call <code>pext</code> or parallel extract, and then take the complement of the result to get the rank-select bit-string we sought.</p>
<p>The other rank-select bit-string which marks delimiters and newlines can be derived by applying the same algorithm for the delimiters and the newlines separately then taking the bitwise OR <code>(.|.)</code> of the two resulting bit-strings.</p>
<p>The resulting code is show below.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">testWord8s ::</span> <span class="dt">Word64</span> <span class="ot">-&gt;</span> <span class="dt">Word64</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">testWord8s w <span class="fu">=</span>  <span class="kw">let</span> w8s <span class="fu">=</span> w</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">                    w4s <span class="fu">=</span> (w8s <span class="fu">.&amp;.</span> <span class="bn">0x0f0f0f0f0f0f0f0f</span>) <span class="fu">.|.</span> (w8s <span class="fu">.&amp;.</span> <span class="bn">0xf0f0f0f0f0f0f0f0</span> <span class="fu">.&gt;.</span> <span class="dv">4</span>)</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">                    w2s <span class="fu">=</span> (w4s <span class="fu">.&amp;.</span> <span class="bn">0x0707070707070707</span>) <span class="fu">.|.</span> (w4s <span class="fu">.&amp;.</span> <span class="bn">0x7070707070707070</span> <span class="fu">.&gt;.</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">                    w1s <span class="fu">=</span> (w2s <span class="fu">.&amp;.</span> <span class="bn">0x0303030303030303</span>) <span class="fu">.|.</span> (w2s <span class="fu">.&amp;.</span> <span class="bn">0x3030303030303030</span> <span class="fu">.&gt;.</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">                <span class="kw">in</span>  pext w1s <span class="bn">0x0101010101010101</span></a>
<a class="sourceLine" id="cb8-7" data-line-number="7"><span class="ot">{-# INLINE testWord8s #-}</span></a></code></pre></div>
<p>All up we’ve used the following operations:</p>
<ul>
<li><code>(.&amp;.)</code> x 6</li>
<li><code>(.|.)</code> x 3</li>
<li><code>(.&gt;.)</code> x 3</li>
<li><code>pext</code> x 1</li>
<li><code>load</code> x 1</li>
<li><code>store</code> x 1</li>
</ul>
<p>Which adds up to <code>13</code> very fast register only instructions plus <code>2</code> implied memory instructions.</p>
<h1 id="optimising-our-bit-string-construction-code">Optimising our bit-string construction code</h1>
<p>If you look at the <code>M</code> row in the diagram you will notice that near the end of the computation we only use the least significant bit from each of the 8 bytes in our word and don’t actually care what the values of the other bits are.</p>
<p>We can exploit this fact to remove some of the operations from our computation by marking those bits as don’t care or <code>x</code>, and tracing those bits backwards through the computation and then figuring out which operations we can omit.</p>
<pre class="text"><code>T   text ┌─── 10100110 00100110 10000110 11110110 11001110 00000000 10000010 11001110
         │                                                                           
A   noop ├──&gt; xxxx0110 xxxx0110 xxxx0110 xxxx0110 xxxx1110 xxxx0000 xxxx0010 xxxx1110 ─┐    
B        │  ┌ 0110xxxx 0110xxxx 0110xxxx 0110xxxx 1110xxxx 0000xxxx 0010xxxx 1110xxxx &lt;┘ (.&gt;. 4)
         │  └────────────────────────────────────────────────────────────────────────────┐
C   noop └──&gt; 1010xxxx 0010xxxx 1000xxxx 1111xxxx 1100xxxx 0000xxxx 1000xxxx 1100xxxx ──┐│
                                                                                        ││
D        ┌─── 1110xxxx 0110xxxx 1110xxxx 1111xxxx 1110xxxx 0000xxxx 1010xxxx 1110xxxx &lt;─┴┘(.|.)
         │                                                                             
E   noop ├──&gt; xx10xxxx xx10xxxx xx10xxxx xx11xxxx xx10xxxx xx00xxxx xx10xxxx xx10xxxx ─┐    
F        │  ┌ 10xxxxxx 10xxxxxx 10xxxxxx 11xxxxxx 10xxxxxx 00xxxxxx 10xxxxxx 10xxxxxx &lt;┘ (.&gt;. 2)
         │  └────────────────────────────────────────────────────────────────────────────┐
G   noop └──&gt; 11xxxxxx 01xxxxxx 11xxxxxx 11xxxxxx 11xxxxxx 00xxxxxx 10xxxxxx 11xxxxxx ──┐│
                                                                                        ││
I        ┌─── 11xxxxxx 11xxxxxx 11xxxxxx 11xxxxxx 11xxxxxx 00xxxxxx 10xxxxxx 11xxxxxx &lt;─┴┘(.|.)
         │                                                                            
J   noop ├──&gt; x1xxxxxx x1xxxxxx x1xxxxxx x1xxxxxx x1xxxxxx x0xxxxxx x1xxxxxx 01xxxxxx ─┐    
K        │  ┌ 1xxxxxxx 1xxxxxxx 1xxxxxxx 1xxxxxxx 1xxxxxxx x0xxxxxx 1xxxxxxx 1xxxxxxx &lt;┘ (.&gt;. 1)
         │  └────────────────────────────────────────────────────────────────────────────┐
L   noop └──&gt; 1xxxxxxx 1xxxxxxx 1xxxxxxx 1xxxxxxx 1xxxxxxx 0xxxxxxx 1xxxxxxx 1xxxxxxx ──┐│
                                                                                        ││
M             1xxxxxxx 1xxxxxxx 1xxxxxxx 1xxxxxxx 1xxxxxxx 0xxxxxxx 1xxxxxxx 1xxxxxxx &lt;─┴┘(.|.)
              │        │        │        └───┐┌───┘        │        │        │
              │        │        └───────────┐││┌───────────┘        │        │
              │        └───────────────────┐││││┌───────────────────┘        │
              └───────────────────────────┐││││││┌───────────────────────────┘
                                          11111011─┐pext
                                          00000100&lt;┘comp</code></pre>
<p>As a result of tracing the don’t care or <code>x</code> bits backwards through the computation, I was able to remove six masks and six AND <code>(.&amp;.)</code> operations.</p>
<p>I left the rows <code>A</code>, <code>C</code>, <code>E</code>, <code>G</code>, <code>J</code>, and <code>L</code> in as non-operations (<code>noop</code>) because I wanted to annotate the additional bits I don’t care beyond those I already don’t care about in the original value.</p>
<p>The resulting code is much simpler and faster:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">testWord8s ::</span> <span class="dt">Word64</span> <span class="ot">-&gt;</span> <span class="dt">Word64</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">testWord8s w <span class="fu">=</span>  <span class="kw">let</span> w8s <span class="fu">=</span> w</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">                    w4s <span class="fu">=</span> w8s <span class="fu">.|.</span> (w8s <span class="fu">.&gt;.</span> <span class="dv">4</span>)</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">                    w2s <span class="fu">=</span> w4s <span class="fu">.|.</span> (w4s <span class="fu">.&gt;.</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">                    w1s <span class="fu">=</span> w2s <span class="fu">.|.</span> (w2s <span class="fu">.&gt;.</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb10-6" data-line-number="6">                <span class="kw">in</span>  pext w1s <span class="bn">0x0101010101010101</span></a>
<a class="sourceLine" id="cb10-7" data-line-number="7"><span class="ot">{-# INLINE testWord8s #-}</span></a></code></pre></div>
<p>The optimisations meas we now use only these operations:</p>
<ul>
<li><code>(.|.)</code> x 3</li>
<li><code>(.&gt;.)</code> x 3</li>
<li><code>pext</code> x 1</li>
<li><code>load</code> x 1</li>
<li><code>store</code> x 1</li>
</ul>
<p>This adds up to <code>7</code> very fast register only instructions plus <code>2</code> implied memory instructions, which is very close to <code>1</code> instruction per byte.</p>
<h2 id="unanswered-questions">Unanswered questions</h2>
<p>What’s nice about it is that we are parsing 8-bytes at a time using fewer instructions and we’ve managed to avoid any branches or memory allocations within each iteration that could slow the iteration down.</p>
<p>Nevertheless, some benchmarks will be necessary to compare this approach to one that parses a byte at a time.</p>
<p>You may have noticed that I have used the <code>pext</code> operation without properly describing how it works nor explained why that operation should be fast.</p>
<p>I will follow up in a future post to explain the <code>pext</code> operation in detail and offer some benchmarks to show the degree of speed up we might expect from exploiting data parallelism in our parsers.</p>
<h2 id="source-code">Source code</h2>
<p>You can play with the source code here:</p>
<p>https://github.com/haskell-works/hw-simd/blob/master/src/HaskellWorks/Data/Simd/Internal/Bits.hs#L9</p>]]></description>
    <pubDate>Wed, 08 Aug 2018 00:00:00 UT</pubDate>
    <guid>https://haskell-works.github.io/posts/2018-08-08-data-parallel-rank-select-bit-string-construction.html</guid>
    <dc:creator>Haskell Works</dc:creator>
</item>
<item>
    <title>Introduction to the rank-select bit-string</title>
    <link>https://haskell-works.github.io/posts/2018-08-01-introduction-to-rank-select-bit-string.html</link>
    <description><![CDATA[<p><a href="../posts/2018-07-25-problem-of-parsing-large-datasets.html">Last week</a> we looked at how traditional whole-document parsers struggle to parse big files.</p>
<p><img style="float: right; height: 300px; width: 300px;" src="/images/golden-toilet.png"> Such parsers both too use much memory and are too slow, being orders of magnitude slower than what IO bandwidth would allow.</p>
<p>In some sense, we can understand the slowness as a consequence large memory usage: All that memory access does not come for free.</p>
<p>Traditional whole-document parsers spend a lot of time allocating memory, assigning pointers, following indirections and touching new memory that isn’t cached in the CPU cache where it could have been accessed much more quickly.</p>
<p>To achieve high performance, the parser needs to do as little possible, but traditional parsers are actually creating a lot of work for the hardware, that is incidental to solving the problem of making the document data accessible and much of that overhead is hidden from us, the developer, by language and hardware abstractions, so the overhead is easy to overlook.</p>
<p>We have seen how objects are severely expensive, especially when allocated en-mass. For our use-case their cost disproportionately exceeds their utility.</p>
<h1 id="if-not-objects-then-what">If not objects then what</h1>
<p>If we want to minimise memory usage, the first thing you should do is avoid duplicating data.</p>
<p>All the data we want to access is already in the document. Copying that data into intermediate objects so that we can work with them is wasteful.</p>
<p><img style="float: right; height: 300px; width: 300px;" src="/images/bits-in-perspective.jpg"> Instead we want to reuse the data in its original form as much as possible and leave the parsing of small individual elements of the document to the last moment just before we use them and in that way avoid parsing all the parts of the document we don’t need.</p>
<p>What prevents us from doing that exactly that is that we lack the means to navigate the structure of the document to locate the various pieces of data in the document we are interested in.</p>
<p>This structure is exactly what our object-based document object model provided, but to avoid paying their dues, we must find another way.</p>
<p>But if not objects, then what?</p>
<p>If you want to find something extremely small and light weight, you could do worse than choose the humble bit. It is 64 times smaller than a pointer and many multiples of that smaller than an object.</p>
<p>So let’s do exactly that: Let’s use bits!</p>
<h1 id="the-rank-select-bit-string">The rank-select bit-string</h1>
<p>Before we can pull this off we are going to have to learn us some concepts.</p>
<p>Imagine a string of bits. Not unlike the following:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">let</span> bs <span class="fu">=</span> <span class="st">&quot;101000000010000000100000010001000000100000&quot;</span></a></code></pre></div>
<p>In order to query this bit-string we will be using two very powerful query operations <strong>rank</strong> and <strong>select</strong>.</p>
<p>The pseudocode for these to operations are provided below in Haskell which you can drop into your Haskell repl to observe their behaviours:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Data.List</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="ot">popCount1 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">popCount1 bs <span class="fu">=</span> length (filter (<span class="fu">==</span> <span class="ch">&#39;1&#39;</span>) bs)</a>
<a class="sourceLine" id="cb2-5" data-line-number="5"></a>
<a class="sourceLine" id="cb2-6" data-line-number="6"><span class="ot">rank1 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">rank1 bs n <span class="fu">=</span> popCount1 (take n bs)</a>
<a class="sourceLine" id="cb2-8" data-line-number="8"></a>
<a class="sourceLine" id="cb2-9" data-line-number="9"><span class="ot">select1 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb2-10" data-line-number="10">select1 bs n <span class="fu">=</span> length (head (dropWhile ((<span class="fu">&lt;</span> n) <span class="fu">.</span> popCount1) (inits (filter isBinary bs))))</a>
<a class="sourceLine" id="cb2-11" data-line-number="11">  <span class="kw">where</span> isBinary c <span class="fu">=</span> c <span class="fu">==</span> <span class="ch">&#39;0&#39;</span> <span class="fu">||</span> c <span class="fu">==</span> <span class="ch">&#39;1&#39;</span></a></code></pre></div>
<p>The first function <code>popCount1</code> is the <strong>population</strong> operation (sometimes called the <a href="https://en.wikipedia.org/wiki/Hamming_weight">hamming weight</a>). It tells us how many <code>1</code> bits there are in our bit-string.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1">λ<span class="fu">&gt;</span> popCount1 bs</a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="dv">7</span></a></code></pre></div>
<p>The second function <code>rank1</code> is the <strong>rank</strong> operation which tells us the population count of the length <code>n</code> prefix of our bit-string.</p>
<p>Here are some example <strong>rank</strong> queries:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">λ<span class="fu">&gt;</span> rank1 bs <span class="dv">0</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="dv">0</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">λ<span class="fu">&gt;</span> rank1 bs <span class="dv">1</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="dv">1</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">λ<span class="fu">&gt;</span> rank1 bs <span class="dv">2</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6"><span class="dv">1</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7">λ<span class="fu">&gt;</span> rank1 bs <span class="dv">3</span></a>
<a class="sourceLine" id="cb4-8" data-line-number="8"><span class="dv">2</span></a>
<a class="sourceLine" id="cb4-9" data-line-number="9">λ<span class="fu">&gt;</span> rank1 bs <span class="dv">14</span></a>
<a class="sourceLine" id="cb4-10" data-line-number="10"><span class="dv">3</span></a></code></pre></div>
<p>The third function <code>select1</code> is the <strong>select</strong> operation which tells us smallest prefix of the given bit-string with the given population <code>n</code>.</p>
<p>Here are some example <strong>select</strong> queries:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1">λ<span class="fu">&gt;</span> select1 bs <span class="dv">0</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="dv">0</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">λ<span class="fu">&gt;</span> select1 bs <span class="dv">1</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="dv">1</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">λ<span class="fu">&gt;</span> select1 bs <span class="dv">2</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6"><span class="dv">3</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7">λ<span class="fu">&gt;</span> select1 bs <span class="dv">3</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8"><span class="dv">11</span></a>
<a class="sourceLine" id="cb5-9" data-line-number="9">λ<span class="fu">&gt;</span> select1 bs <span class="dv">4</span></a>
<a class="sourceLine" id="cb5-10" data-line-number="10"><span class="dv">19</span></a></code></pre></div>
<p>In less precise terms, the <strong>rank</strong> gives us how many <code>1s</code> up to a given position <code>n</code> in our bit-string and <strong>select</strong> gives us the position of the <code>n</code><sup><code>th</code></sup> <code>1</code> in our bit-string.</p>
<h1 id="rank-select-bit-string-as-an-index-into-json">Rank-Select Bit-String as an index into JSON</h1>
<p>We will now use the rank-select bit-string to index into JSON, which is to say we will use it to locate interesting locations in our JSON document that correspond to the beginning of JSON nodes.</p>
<p>In our semi-index, every bit in the rank-select bit-string corresponds to a byte in the original document of the same position. The value of each bit is chosen such that when the byte represents the start of a node in the document it will be set to <code>1</code>. Otherwise it will be set to <code>0</code>.</p>
<p>For JSON, the beginning of every object (indicated by <code>{</code>), every array (indiciated by <code>[</code>), every field or value will be marked with a <code>1</code>, and all other bytes are marked with a <code>0</code>.</p>
<p>The example below demonstrates this mapping from bytes to bits:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode json"><code class="sourceCode json"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="fu">{</span> <span class="dt">&quot;name&quot;</span><span class="fu">:</span> <span class="st">&quot;John&quot;</span><span class="fu">,</span> <span class="dt">&quot;age&quot;</span><span class="fu">:</span> <span class="dv">30</span><span class="fu">,</span> <span class="dt">&quot;car&quot;</span><span class="fu">:</span> <span class="kw">null</span><span class="fu">,</span> <span class="er">colors</span><span class="fu">:</span> <span class="ot">[</span><span class="dv">1</span><span class="ot">,</span> <span class="dv">2</span><span class="ot">,</span> <span class="dv">3</span><span class="ot">]</span> <span class="fu">}</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="er">1010000000100000001000000100010000001000001000000011001001000</span></a></code></pre></div>
<p>What this gives us is the ability to locate the <code>n</code><sup><code>th</code></sup> node in the document with <strong>rank-select</strong> operations.</p>
<p>For example the <code>6</code><sup><code>th</code></sup> node is marked by the <code>6</code><sup><code>th</code></sup> <code>1</code> bit at the location that corresponds to the field-name <code>&quot;car&quot;</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">λ<span class="fu">&gt;</span> <span class="kw">let</span> text <span class="fu">=</span> <span class="st">&quot;{ \&quot;name\&quot;: \&quot;John\&quot;, \&quot;age\&quot;: 30, \&quot;car\&quot;: null, numbers: [1, 2, 3] }&quot;</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">λ<span class="fu">&gt;</span> <span class="kw">let</span> bs   <span class="fu">=</span> <span class="st">&quot;101 00000 001 00000 0010 00000 10001000 00010 000010000000011001001000&quot;</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">λ<span class="fu">&gt;</span> <span class="kw">let</span> offset <span class="fu">=</span> select1 bs <span class="dv">6</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4"><span class="dv">31</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">λ<span class="fu">&gt;</span> drop (offset <span class="fu">-</span> <span class="dv">1</span>) text</a>
<a class="sourceLine" id="cb7-6" data-line-number="6"><span class="st">&quot;\&quot;car\&quot;: null, numbers: [1, 2, 3] }&quot;</span></a></code></pre></div>
<p>In another example, the <code>9</code><sup><code>th</code></sup> node is marked by the <code>9</code><sup><code>th</code></sup> <code>1</code> bit at the location that corresponds to the beginning of the JSON array:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">λ<span class="fu">&gt;</span> <span class="kw">let</span> text <span class="fu">=</span> <span class="st">&quot;{ \&quot;name\&quot;: \&quot;John\&quot;, \&quot;age\&quot;: 30, \&quot;car\&quot;: null, numbers: [1, 2, 3] }&quot;</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">λ<span class="fu">&gt;</span> <span class="kw">let</span> bs   <span class="fu">=</span> <span class="st">&quot;101 00000 001 00000 0010 00000 10001000 00010 000010000000011001001000&quot;</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">λ<span class="fu">&gt;</span> <span class="kw">let</span> offset <span class="fu">=</span> select1 bs <span class="dv">9</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4"><span class="dv">52</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5">λ<span class="fu">&gt;</span> drop (offset <span class="fu">-</span> <span class="dv">1</span>) text</a>
<a class="sourceLine" id="cb8-6" data-line-number="6"><span class="st">&quot;[1, 2, 3] }&quot;</span></a></code></pre></div>
<p>You may notice that each successive <code>1</code> bit in the rank-select bit-string identifies nodes of the document according to pre-order traversal.</p>
<p>It is also worth noting that the rank-select bit-string in combination with the original text can be used to identify the type of the node in <code>O(1)</code> time, by testing the character pointed to by the rank-select bit-string.</p>
<p>For example, we know the <code>6</code><sup><code>th</code></sup> node in the document is a string because the character at line <code>31</code> is a <code>&quot;</code>, whilst the <code>9</code><sup><code>th</code></sup> node is an array because the character at line <code>52</code> is a <code>[</code>.</p>
<h1 id="rank-select-bit-string-as-an-index-into-csv">Rank-Select Bit-String as an index into CSV</h1>
<p>Rank-select bit-strings can be used to index into a CSV document in a similar fashion, but I have chosen to use two rank-select bit-strings instead of one.</p>
<p>Take the following CSV document</p>
<pre class="text"><code>&quot;name&quot;,&quot;age&quot;,&quot;profession&quot;
John,30,Code Monkey
Kyle,40,Data Scrubber</code></pre>
<p>I will represent this document on a single line for easier comparison with the two rank-select bit-strings that follow:</p>
<pre class="text"><code>&quot;name&quot;,&quot;age&quot;,&quot;profession&quot;␤John,30,Code Monkey␤Kyle,40,Data Scrubber
0000001000001000000000000100001001000000000001000010010000000000000
0000000000000000000000000100000000000000000001000000000000000000000</code></pre>
<p>The first rank-select bit-string marks both delimiters and newlines and helps us find the beginning of fields, whilst the other rank-select bit-string marks newlines only and helps us find the beginning of rows.</p>
<p>Having two rank-select bit-strings affords us operations like row count, and field count (either per document or per row) without having to inspect the original document text at all.</p>
<p>If you’re interested with playing with the haskell-works library which works on real bit-vectors (rather than emulation on strings), head over to the <a href="http://github.com/haskell-works/hw-rankselect-base">hw-rankselect-base</a> project page.</p>
<h1 id="other-ingredients-to-a-fast-json-or-csv-parser">Other ingredients to a fast JSON or CSV parser</h1>
<p>A rank-select bit-string by itself won’t get us a fast JSON or CSV parser.</p>
<p>We will need high performance <strong>rank</strong> and <strong>select</strong> operations for both short and very long bit-strings to make this practical.</p>
<p>We haven’t talked about the implications this has for whole document or streaming parsers either.</p>
<p>Nor have we discussed how to build rank-select bit-strings efficiently and then use them to parse the document in a way that is competitive with traditional parsers.</p>
<p>Furthermore, the rank-select bit-string is insufficient for parsing heirarchical document formats such as JSON because it does not allow for tree traversal.</p>
<p>Whilst we know the nodes are ordered in pre-order traversal order, we have lost information about parent-child or sibling-sibling relationships between nodes, and so are unable traverse in such a way as to, for example, construct a tree of nodes that resemble the document.</p>
<p>An additional index is required to make proper tree-traversal of the document possible.</p>
<p>Alas, these and other questions must remain for a future post.</p>
<h1 id="references">References</h1>
<p><a href="http://www.di.unipi.it/~ottavian/files/semi_index_cikm.pdf">Semi-Indexing Semi-Structured Data in Tiny Space</a></p>]]></description>
    <pubDate>Wed, 01 Aug 2018 00:00:00 UT</pubDate>
    <guid>https://haskell-works.github.io/posts/2018-08-01-introduction-to-rank-select-bit-string.html</guid>
    <dc:creator>Haskell Works</dc:creator>
</item>
<item>
    <title>The problem of parsing large datasets</title>
    <link>https://haskell-works.github.io/posts/2018-07-25-problem-of-parsing-large-datasets.html</link>
    <description><![CDATA[<p>In data processing, the volume of data can be so large that the amount of time it takes to process a file matters. In my work, I try to optimise such jobs so that it is more efficient, but surprisingly, it is often not the business logic that is the bottleneck, but the parsing of files itself that consumes large amounts of CPU and memory.</p>
<h1 id="memory-usage">Memory usage</h1>
<p>Memory in particular can be a serious problem because we store files in S3 where the pricing model and latency of <code>GET</code> queries favours the storage of large files in the hundreds of MBs each.</p>
<p>The danger with storing such large files, however, is we can run out of memory just trying to parse them.</p>
<p>To illustrate the problem, here is a sample program that parses a JSON file and reports how much memory it uses before exiting.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Control.Monad</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw">import</span> <span class="dt">Data.Aeson</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">import</span> <span class="dt">GHC.Stats</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="kw">import</span> <span class="dt">System.Posix.Process</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="kw">import</span> <span class="dt">System.Process</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString.Lazy</span> <span class="kw">as</span> <span class="dt">BS</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">System.Environment</span>   <span class="kw">as</span> <span class="dt">IO</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9"></a>
<a class="sourceLine" id="cb1-10" data-line-number="10"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb1-11" data-line-number="11">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12">  pid <span class="ot">&lt;-</span> getProcessID</a>
<a class="sourceLine" id="cb1-13" data-line-number="13">  (filename<span class="fu">:</span>_) <span class="ot">&lt;-</span> <span class="dt">IO</span><span class="fu">.</span>getArgs</a>
<a class="sourceLine" id="cb1-14" data-line-number="14">  bs <span class="ot">&lt;-</span> BS.readFile filename</a>
<a class="sourceLine" id="cb1-15" data-line-number="15">  <span class="kw">let</span> <span class="fu">!</span>maybeJson <span class="fu">=</span> decode<span class="ot"> bs ::</span> <span class="dt">Maybe</span> <span class="dt">Value</span></a>
<a class="sourceLine" id="cb1-16" data-line-number="16"></a>
<a class="sourceLine" id="cb1-17" data-line-number="17">  system <span class="fu">$</span> <span class="st">&quot;ps aux | grep &quot;</span> <span class="fu">&lt;&gt;</span> show pid <span class="fu">&lt;&gt;</span> <span class="st">&quot; | grep -v grep&quot;</span></a>
<a class="sourceLine" id="cb1-18" data-line-number="18"></a>
<a class="sourceLine" id="cb1-19" data-line-number="19">  forM_ maybeJson <span class="fu">$</span> \_ <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb1-20" data-line-number="20">    putStrLn <span class="st">&quot;Done&quot;</span></a></code></pre></div>
<p>This program is used to parse a <code>25MB</code> file as follows:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" data-line-number="1">$ <span class="fu">git</span> clone git@github.com:haskell-works/blog-examples.git</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">$ <span class="bu">cd</span> blog-examples/simple-json</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">$ <span class="ex">stack</span> build</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">$ <span class="ex">curl</span> https://data.medicare.gov/api/views/ijh5-nb2v/rows.json\?accessType\=DOWNLOAD <span class="op">&gt;</span> hospitalisation.json</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">$ <span class="fu">ls</span> -lh hospitalisation.json</a>
<a class="sourceLine" id="cb2-6" data-line-number="6"><span class="ex">-rw-r--r--</span>  1 jky  staff    25M 24 Jul 22:00 hospitalisation.json</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">$ <span class="ex">stack</span> exec simple-json hospitalisation.json</a>
<a class="sourceLine" id="cb2-8" data-line-number="8"><span class="ex">jky</span>              32237 394.0  1.9 1078037040 323084 s001  S+   10:05pm   0:03.79 /Users/jky/wrk/haskell-works/blog-examples/simple-json/.stack-work/install/x86_64-osx/lts-12.2/8.4.3/bin/simple-json hospitalisation.json</a>
<a class="sourceLine" id="cb2-9" data-line-number="9"><span class="ex">Done</span></a></code></pre></div>
<p>The program self-reports that after parsing the file, it is using <code>394MB</code> of memory!</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" data-line-number="1">$ <span class="bu">time</span> gzip hospitalisation.json</a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="fu">gzip</span> hospitalisation.json  0.55s user 0.02s system 96% cpu 0.595 total</a></code></pre></div>
<p>The discrepancy is even larger if we consider that large files stored in S3 are often compressed:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" data-line-number="1">$ <span class="fu">gzip</span> hospitalisation.json</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">$ <span class="fu">ls</span> -lh hospitalisation.json.gz</a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="ex">-rw-r--r--</span>  1 jky  staff   4.5M 24 Jul 22:00 hospitalisation.json.gz</a></code></pre></div>
<p>So now we’re look at unzipping and then parsing at a memory cost of <code>394M</code>, or <code>87x</code> the size of the compressed <code>4.5MB</code> file or <code>16x</code> the the size of the original <code>25MB</code> file.</p>
<h2 id="why-does-this-happen">Why does this happen</h2>
<p>JSON is hardly a compact serialisation format to start with, so the amount of memory required for parsing is quite astonishing.</p>
<p>Let’s take a look at the data type that describes that data that composes a typical JSON document:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Json</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">JsonString</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  <span class="fu">|</span> <span class="dt">JsonNumber</span> <span class="dt">Double</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">  <span class="fu">|</span> <span class="dt">JsonObject</span> [(<span class="dt">String</span>, <span class="dt">Json</span>)]</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">  <span class="fu">|</span> <span class="dt">JsonArray</span> [<span class="dt">Json</span>]</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">  <span class="fu">|</span> <span class="dt">JsonBool</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7">  <span class="fu">|</span> <span class="dt">JsonNull</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a></code></pre></div>
<p>This can be explained by the cost of pointers.</p>
<p>A large document, will have lots of pointers connecting all the JSON nodes and they cost 64-bits each on modern CPU architectures.</p>
<p>The image below constrasts the amount of memory allocated to actual data (green) versus the amount of memory allocated to pointers (purple) and other housekeeping information maintained by the runtime (blue).</p>
<figure>
<img src="/images/json-object-on-the-heap.png" alt="JSON Object on the Heap" /><figcaption>JSON Object on the Heap</figcaption>
</figure>
<p>The header exists because the <code>Json</code> type is a tagged type and the runtime needs a place to store additional information (the tag) to know which constructor is relevant for interpreting the payload.</p>
<ul>
<li>A <code>JsonBool</code> could theoretically be represented by one bit if represented as an unboxed and packed 1-bit integer. But given that Haskell’s <code>Bool</code> is a data type with two constructors, it is likely to be represented as a pointer to a <code>True</code> or <code>False</code> value as depicted here in green following the header, totalling 16-bytes.</li>
<li>A <code>JsonNumber</code> might be represented in 8 bytes, but with the header, it is still 16-bytes.</li>
<li>A <code>JsonString</code> is especially egrerious especially because it uses the <code>String</code> type but other representations like <code>Text</code>, whilst improvement, still leaves a lot of overhead.</li>
<li>A <code>JsonArray</code> is going to introduce a lot of overhead, because the payload typically is typed with <code>[Json]</code>, and the cons cells use to construct a list will use a lot of memory for headers and pointers per element. Imagine how much member an array like [1,2,3,4,5] would use!</li>
</ul>
<p>More information our how GHC allocates memory can be found <a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects">here</a>.</p>
<p>Hopefully, these examples have convinced you of the absurdity of using in-memory documents to represent large datasets.</p>
<h1 id="cpu-usage-and-io-boundedness">CPU usage and IO boundedness</h1>
<p>Another point of consideration when parsing large datasets is how long it takes to parse the file. Often we would just dismiss the slowness to the parsing being IO bound, but is it really?</p>
<p>Here we measure how long it takes to parse a <code>25MB</code> JSON file (on my Macbook Pro):</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb6-1" data-line-number="1">$ <span class="bu">time</span> stack exec simple-json hospitalisation.json <span class="op">&gt;</span> /dev/null</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="ex">stack</span> exec simple-json hospitalisation.json <span class="op">&gt;</span> /dev/null  2.96s user 1.21s system 328% cpu 1.270 total</a></code></pre></div>
<p>At <code>8.44 MB/s</code> (from <code>25 MB / 2.96 s</code>), is that fast or close to IO bound?</p>
<p>Not even close.</p>
<p>Below, we see that command line tool <code>cut</code> can select the first two columns out of a CSV file at a rate of <code>76MiB/s</code>, almost an order of magnitude faster.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb7-1" data-line-number="1">$ <span class="fu">cat</span> ~/7g.csv <span class="kw">|</span> <span class="ex">pv</span> -t -e -b -a <span class="kw">|</span> <span class="fu">cut</span> -d , -f 1 -f 2 <span class="op">&gt;</span> /dev/null</a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="ex">7.08GiB</span> 0:01:35 [76.0MiB/s]</a></code></pre></div>
<p>Are we IO bound yet?</p>
<p>Other programs are faster. For example:</p>
<p>Character count:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb8-1" data-line-number="1">$ <span class="fu">cat</span> ~/7g.csv <span class="kw">|</span> <span class="ex">pv</span> -t -e -b -a <span class="kw">|</span> <span class="fu">wc</span> -c <span class="op">&gt;</span> /dev/null</a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="ex">7.08GiB</span> 0:00:24 [ 298MiB/s]</a></code></pre></div>
<p>Line count:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb9-1" data-line-number="1">$ <span class="fu">cat</span> ~/7g.csv <span class="kw">|</span> <span class="ex">pv</span> -t -e -b -a <span class="kw">|</span> <span class="fu">wc</span> -l <span class="op">&gt;</span> /dev/null</a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="ex">7.08GiB</span> 0:00:08 [ 819MiB/s]</a></code></pre></div>
<p>Or remove <code>wc</code> altogether so we just have <code>cat</code> and <code>pv</code>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb10-1" data-line-number="1">$ <span class="fu">cat</span> ~/7g.csv <span class="kw">|</span> <span class="ex">pv</span> -t -e -b -a <span class="op">&gt;</span> /dev/null</a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="ex">7.08GiB</span> 0:00:02 [2.56GiB/s]</a></code></pre></div>
<p>It’s probably safe to say, JSON parsing with a traditional style parser will, depending on the specifics of the hardware, be one to three orders of magnitude slower than speeds where it could be considered to be IO bound.</p>
<h1 id="where-to-from-here">Where to from here</h1>
<p>In the near future, I’d like to describe on this blog how the <code>haskell-works</code> parsing libraries address these and other problems, and future directions the libraries might take.</p>
<p>Among the topics I hope to explore are:</p>
<ul>
<li>how succinct data-structures can be used to parse files with a lot less memory</li>
<li>how succinct data-structures look internally</li>
<li>how to create a semi-index into files so that work used to parse a file can be re-used by later jobs</li>
<li>how the laziness of the Haskell language can be exploited to avoid parsing unused data</li>
<li>how validation, indexing and parsing can be different steps</li>
<li>how validation and indexing can be parallelised</li>
<li>how simd and bit-manipulation instructions can be used to optimise parsing and succinct data-structures</li>
</ul>]]></description>
    <pubDate>Wed, 25 Jul 2018 00:00:00 UT</pubDate>
    <guid>https://haskell-works.github.io/posts/2018-07-25-problem-of-parsing-large-datasets.html</guid>
    <dc:creator>Haskell Works</dc:creator>
</item>

    </channel>
</rss>
